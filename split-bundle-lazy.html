<!DOCTYPE html>
<html>
<head>
    <title>BusyTeX Lazy Loading Test</title>
    <style>
        body { font-family: system-ui; max-width: 1200px; margin: 0 auto; padding: 20px; }
        .container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; height: 70vh; }
        textarea { width: 100%; height: 100%; font-family: monospace; font-size: 14px; }
        #pdfViewer { width: 100%; height: 100%; border: 1px solid #ccc; overflow-y: auto; background: #525659; }
        #pdfViewer .page-container { margin: 10px auto; box-shadow: 0 2px 8px rgba(0,0,0,0.3); }
        #pdfViewer canvas { display: block; }
        .controls { margin-bottom: 20px; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
        button { padding: 10px 20px; font-size: 16px; cursor: pointer; }
        button:disabled { opacity: 0.6; cursor: not-allowed; }
        #status { margin-top: 10px; padding: 10px; background: #f5f5f5; font-family: monospace; font-size: 12px; max-height: 300px; overflow-y: auto; white-space: pre-wrap; }
        .stats { padding: 10px; background: #e3f2fd; border-radius: 4px; font-size: 14px; margin-bottom: 10px; }
        .warning { background: #fff3e0; color: #e65100; padding: 8px; margin: 5px 0; border-radius: 4px; }
        .missing-pkg { background: #ffebee; color: #c62828; }
    </style>
</head>
<body>
    <h1>BusyTeX Lazy Loading - Fetch Files On-Demand</h1>
    <p>Files are fetched individually as TeX requests them. Only downloads what's actually needed.</p>

    <div class="stats" id="stats">
        <strong>Files fetched:</strong> <span id="fileCount">0</span> |
        <strong>Bytes downloaded:</strong> <span id="bytesDownloaded">0</span> KB |
        <strong>Requests:</strong> <span id="requestCount">0</span> |
        <strong>CTAN fetches:</strong> <span id="ctanCount">0</span> |
        <strong>Cache hits:</strong> <span id="cacheHits">0</span> |
        <strong>Lazy loads:</strong> <span id="lazyLoads">0</span>
    </div>

    <div class="controls">
        <button onclick="compileWithLazyLoading()" id="compileBtn">Compile (Lazy Loading)</button>
        <select id="engineSelect">
            <option value="auto">Auto-detect engine</option>
            <option value="xelatex">XeLaTeX (Unicode/fonts)</option>
            <option value="pdflatex">pdfLaTeX (simple docs)</option>
        </select>
        <label>
            <input type="checkbox" id="enableCtan" checked>
            Enable CTAN fetch for missing packages
        </label>
        <label>
            <input type="checkbox" id="enableLazyFS" checked>
            Lazy FS (load file contents on-demand)
        </label>
        <label>
            <input type="checkbox" id="enableAutoCompile">
            Auto-compile
        </label>
        <label>
            <input type="checkbox" id="enableKeyupCompile">
            Compile on keyup
        </label>
        <label>
            <input type="checkbox" id="enableWorker" checked>
            Use Worker (async)
        </label>
        <button onclick="clearCTANCache()" style="font-size: 12px; padding: 5px 10px;">Clear CTAN Cache</button>
        <button onclick="testFormatGeneration()" style="font-size: 12px; padding: 5px 10px;">Generate Format</button>
        <span id="time"></span>
    </div>

    <div id="missingPackages"></div>

    <div class="container">
        <div>
            <h3>LaTeX Source</h3>
            <textarea id="source">\documentclass{article}
\usepackage{amsmath}

\begin{document}

Hello, world!

$E = mc^2$

\end{document}</textarea>
        </div>
        <div>
            <h3>PDF Preview <span id="renderStats" style="font-weight: normal; font-size: 12px; color: #666;"></span></h3>
            <div id="pdfViewer"></div>
        </div>
    </div>

    <div id="status">Ready. Click "Compile" to start.</div>

    <!-- PDF.js for incremental rendering -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.mjs" type="module"></script>
    <script type="module">
        // PDF.js setup
        const pdfjsLib = await import('https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.min.mjs');
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.0.379/pdf.worker.min.mjs';

        // ============================================================
        // Incremental PDF Viewer - Only re-renders changed pages
        // ============================================================
        const IncrementalPDFViewer = {
            container: null,
            pageCache: new Map(),  // pageNum -> { hash, canvas }
            currentPdf: null,
            scale: 1.5,
            lastRenderStats: { total: 0, rerendered: 0, cached: 0 },

            init(containerId) {
                this.container = document.getElementById(containerId);
            },

            // Fast hash of page content - includes text and operators
            async hashPage(page) {
                // Get text content for accurate text change detection
                const textContent = await page.getTextContent();
                const textStr = textContent.items.map(item => item.str || '').join('');

                // Also get operator list for structural changes
                const ops = await page.getOperatorList();
                const opsStr = ops.fnArray.join(',');

                // Combine text + structure for hash
                const combined = textStr + '|' + opsStr + '|' + ops.argsArray.length;

                // djb2 hash
                let hash = 5381;
                for (let i = 0; i < combined.length; i++) {
                    hash = ((hash << 5) + hash) + combined.charCodeAt(i);
                    hash = hash & hash;
                }
                return hash;
            },

            async render(pdfBytes) {
                const startTime = performance.now();
                const pdf = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                const numPages = pdf.numPages;

                let rerendered = 0;
                let cached = 0;

                // Ensure we have the right number of page containers
                this.ensurePageContainers(numPages);

                // Process each page
                for (let i = 1; i <= numPages; i++) {
                    const page = await pdf.getPage(i);
                    const hash = await this.hashPage(page);
                    const cachedPage = this.pageCache.get(i);

                    if (cachedPage && cachedPage.hash === hash) {
                        // Page unchanged - canvas is already displayed with correct content
                        cached++;
                        continue;
                    }

                    // Page changed or new - render it
                    rerendered++;
                    const canvas = await this.renderPage(page, i);
                    this.pageCache.set(i, { hash, canvas });
                }

                // Remove extra pages if document got shorter
                for (let i = numPages + 1; this.pageCache.has(i); i++) {
                    this.pageCache.delete(i);
                }

                // Clean up extra containers
                while (this.container.children.length > numPages) {
                    this.container.removeChild(this.container.lastChild);
                }

                this.currentPdf = pdf;
                const renderTime = performance.now() - startTime;

                this.lastRenderStats = { total: numPages, rerendered, cached };

                // Update stats display
                const statsEl = document.getElementById('renderStats');
                if (statsEl) {
                    if (cached > 0) {
                        statsEl.textContent = `(${rerendered}/${numPages} pages rendered, ${cached} cached, ${renderTime.toFixed(0)}ms)`;
                        statsEl.style.color = '#2e7d32';  // Green when caching helps
                    } else {
                        statsEl.textContent = `(${numPages} pages, ${renderTime.toFixed(0)}ms)`;
                        statsEl.style.color = '#666';
                    }
                }

                return this.lastRenderStats;
            },

            ensurePageContainers(numPages) {
                // Add containers for new pages
                for (let i = this.container.children.length; i < numPages; i++) {
                    const pageContainer = document.createElement('div');
                    pageContainer.className = 'page-container';
                    pageContainer.dataset.pageNum = i + 1;

                    const canvas = document.createElement('canvas');
                    pageContainer.appendChild(canvas);
                    this.container.appendChild(pageContainer);
                }
            },

            async renderPage(page, pageNum) {
                const viewport = page.getViewport({ scale: this.scale });
                const container = this.container.children[pageNum - 1];
                const displayCanvas = container.querySelector('canvas');

                // Render to offscreen canvas first to avoid blink
                const offscreen = document.createElement('canvas');
                offscreen.width = viewport.width;
                offscreen.height = viewport.height;
                const offscreenCtx = offscreen.getContext('2d');

                await page.render({
                    canvasContext: offscreenCtx,
                    viewport: viewport
                }).promise;

                // Now swap in the rendered content atomically
                displayCanvas.width = viewport.width;
                displayCanvas.height = viewport.height;
                const displayCtx = displayCanvas.getContext('2d');
                displayCtx.drawImage(offscreen, 0, 0);

                return displayCanvas;
            },

            clear() {
                this.pageCache.clear();
                this.container.innerHTML = '';
                this.currentPdf = null;
            }
        };

        // Initialize and expose globally
        IncrementalPDFViewer.init('pdfViewer');
        window.IncrementalPDFViewer = IncrementalPDFViewer;
    </script>

    <script>
        const BUNDLE_BASE = 'packages/bundles';
        const CTAN_PROXY = 'http://localhost:8081';  // Local CTAN proxy server

        let fileManifest = null;
        let bundleFilenames = null;  // Set of .sty/.cls/.def filenames from bundles (for duplicate detection)
        let packageMap = null;
        let bundleDeps = null;
        let packageDeps = null;  // Package-level dependencies extracted from .sty files
        let bundleRegistry = null;  // List of bundles that actually exist
        let bundleCache = new Map();  // bundle name -> decompressed ArrayBuffer
        let mountedBundles = new Set();  // bundles already mounted to current MEMFS
        let busytexModule = null;
        let busytexScriptLoaded = false;  // Track if busytex.js script is loaded
        let cachedWasmModule = null;  // Cache the compiled WebAssembly.Module for faster re-instantiation

        // Pre-warming: start loading resources before user clicks compile
        let preWarmPromise = null;
        let preWarmedEngine = null;
        let ctanPackageCache = new Map();  // package name -> CTANPackageInfo
        let ctanMountedFiles = new Set();  // Track CTAN-mounted file paths for ls-R
        let ctanFontMapFiles = new Set();  // Track font .map files that need appending to pdftex.map

        // IndexedDB for package metadata/references, OPFS for large file data
        let idbCache = null;
        let opfsRoot = null;
        const IDB_NAME = 'siglum-ctan-cache';
        const IDB_STORE = 'packages';
        const CTAN_CACHE_VERSION = 6;  // Increment to invalidate old caches (v6: alias + notFound caching)
        const BUNDLE_CACHE_VERSION = 4;  // Increment to invalidate bundle OPFS cache (v4: package-level deps for proper resolution)

        // ============================================================
        // Web Worker Infrastructure for Compilation
        // ============================================================

        let compilationWorker = null;
        let workerReady = false;
        let pendingCompileResolve = null;
        let pendingCompileReject = null;
        let currentCompileId = null;

        // Pending CTAN fetch requests from worker
        const pendingCtanFetches = new Map();  // requestId -> { resolve, reject }

        // Create the worker code as a blob URL
        function createWorkerCode() {
            const code = `
// ============================================================
// Compilation Worker
// ============================================================

const BUNDLE_BASE = 'packages/bundles';
const CTAN_PROXY = 'http://localhost:8081';

// Worker state
let cachedWasmModule = null;
let busytexJsUrl = null;
let fileManifest = null;
let packageMap = null;
let bundleDeps = null;
let bundleRegistry = null;
let bundleCache = new Map();  // bundleName -> ArrayBuffer
let mountedBundles = new Set();
let dirNodeCache = new Map();
let ctanMountedFiles = new Set();
let lazyLoadCount = 0;

// Cached manifest index (to avoid re-indexing on every compile)
let cachedBundleFilesMap = null;
let cachedManifestSize = 0;

// Pending CTAN fetch requests
const pendingCtanRequests = new Map();

function workerLog(msg) {
    self.postMessage({ type: 'log', message: msg });
}

function workerProgress(stage, detail) {
    self.postMessage({ type: 'progress', stage, detail });
}

// Request CTAN package from main thread
function requestCtanFetch(packageName) {
    return new Promise((resolve, reject) => {
        const requestId = crypto.randomUUID();
        pendingCtanRequests.set(requestId, { resolve, reject });

        self.postMessage({
            type: 'ctan-fetch-request',
            requestId,
            packageName,
        });

        // Timeout after 60 seconds
        setTimeout(() => {
            if (pendingCtanRequests.has(requestId)) {
                pendingCtanRequests.delete(requestId);
                reject(new Error('CTAN fetch timeout'));
            }
        }, 60000);
    });
}

// Helper: ensure directory exists
function ensureDirectory(FS, dirPath) {
    const parts = dirPath.split('/').filter(p => p);
    let current = '';
    for (const part of parts) {
        current += '/' + part;
        try {
            FS.stat(current);
        } catch (e) {
            try {
                FS.mkdir(current);
            } catch (e2) {
                // May already exist from concurrent create
            }
        }
    }
}

// Lazy content marker - a special object stored in node.contents
// When MEMFS reads from a file with this marker, we resolve the actual content
const LAZY_MARKER_SYMBOL = '__siglum_lazy__';

function createLazyMarker(bundleName, start, end) {
    return {
        [LAZY_MARKER_SYMBOL]: true,
        bundleName,
        start,
        end,
        length: end - start,
        byteLength: end - start
    };
}

function isLazyMarker(obj) {
    return obj && typeof obj === 'object' && obj[LAZY_MARKER_SYMBOL] === true;
}

// Resolve lazy marker to actual Uint8Array content
function resolveLazyContent(marker) {
    const bundleData = bundleCache.get(marker.bundleName);
    if (!bundleData) {
        workerLog('ERROR: Bundle not in cache: ' + marker.bundleName);
        return new Uint8Array(0);
    }
    lazyLoadCount++;
    // Log first few resolutions to verify lazy loading is working
    if (lazyLoadCount <= 5) {
        workerLog('Lazy resolved #' + lazyLoadCount + ' from ' + marker.bundleName + ' (' + (marker.end - marker.start) + ' bytes)');
    }
    return new Uint8Array(bundleData.slice(marker.start, marker.end));
}

// Patch MEMFS to support lazy content resolution
// This is called once after WASM init, before any file operations
function patchMEMFSForLazyLoading(FS) {
    const MEMFS = FS.filesystems.MEMFS;
    if (!MEMFS) {
        workerLog('WARNING: Cannot patch MEMFS - MEMFS not found');
        return false;
    }
    if (!MEMFS.stream_ops) {
        workerLog('WARNING: Cannot patch MEMFS - stream_ops not found');
        return false;
    }

    workerLog('MEMFS structure: stream_ops=' + !!MEMFS.stream_ops + ', node_ops=' + !!MEMFS.node_ops + ', ops_table=' + !!MEMFS.ops_table);

    // Helper to ensure node contents are resolved
    function ensureResolved(node) {
        if (isLazyMarker(node.contents)) {
            const resolved = resolveLazyContent(node.contents);
            node.contents = resolved;
            node.usedBytes = resolved.length;
        }
    }

    // Patch stream_ops.read - main file read path
    const originalRead = MEMFS.stream_ops.read;
    MEMFS.stream_ops.read = function(stream, buffer, offset, length, position) {
        ensureResolved(stream.node);
        return originalRead.call(this, stream, buffer, offset, length, position);
    };

    // NOTE: We intentionally do NOT patch llseek or getattr (stat/fstat)
    // getattr only needs node.mode and node.usedBytes, both of which we set correctly
    // when creating lazy files. Resolving on stat() would defeat lazy loading since
    // generateLsR() calls stat() on every file to check if it's a directory.

    if (MEMFS.ops_table && MEMFS.ops_table.file && MEMFS.ops_table.file.stream && MEMFS.ops_table.file.stream.read) {
        const originalTableRead = MEMFS.ops_table.file.stream.read;
        MEMFS.ops_table.file.stream.read = function(stream, buffer, offset, length, position) {
            ensureResolved(stream.node);
            return originalTableRead.call(this, stream, buffer, offset, length, position);
        };
        workerLog('Patched MEMFS.ops_table.file.stream.read');
    }

    // Patch mmap - some file access goes through memory mapping
    if (MEMFS.stream_ops.mmap) {
        const originalMmap = MEMFS.stream_ops.mmap;
        MEMFS.stream_ops.mmap = function(stream, length, position, prot, flags) {
            ensureResolved(stream.node);
            return originalMmap.call(this, stream, length, position, prot, flags);
        };
        workerLog('Patched MEMFS.stream_ops.mmap');
    }

    if (MEMFS.ops_table && MEMFS.ops_table.file && MEMFS.ops_table.file.stream && MEMFS.ops_table.file.stream.mmap) {
        const originalTableMmap = MEMFS.ops_table.file.stream.mmap;
        MEMFS.ops_table.file.stream.mmap = function(stream, length, position, prot, flags) {
            ensureResolved(stream.node);
            return originalTableMmap.call(this, stream, length, position, prot, flags);
        };
        workerLog('Patched MEMFS.ops_table.file.stream.mmap');
    }

    workerLog('MEMFS patched for lazy loading');
    return true;
}

// Helper: check if file should be eager loaded
// With MEMFS patching, most files can be lazy loaded
// Only eager load files that use memory mapping or are accessed via C-level I/O
function shouldEagerLoad(path) {
    // Format files use mmap and must be eager loaded
    if (path.endsWith('.fmt')) return true;
    // Config files accessed before our patches
    if (path.endsWith('texmf.cnf')) return true;
    // Font map files - pdfTeX reads these via C I/O, not through our patched MEMFS
    if (path.endsWith('.map')) return true;
    // ls-R is generated by us, so no need to check
    // Everything else can be lazy loaded via our MEMFS patch
    return false;
}

// Inject microtype workaround for pdfLaTeX - disable font expansion since we don't have cm-super
// This must be called BEFORE \\documentclass because \\PassOptionsToPackage only works before loading
function injectMicrotypeWorkaround(source) {
    // Check if the document uses microtype
    if (!source.includes('microtype')) {
        return source;
    }

    // Insert \\PassOptionsToPackage before \\documentclass
    const documentclassMatch = source.match(/\\\\documentclass/);
    if (!documentclassMatch) {
        return source;
    }

    const insertPos = documentclassMatch.index;
    const workaround = '% Siglum: Disable microtype font expansion (requires cm-super fonts not available)\\n\\\\PassOptionsToPackage{expansion=false}{microtype}\\n';

    workerLog('Injecting microtype expansion=false workaround');
    return source.slice(0, insertPos) + workaround + source.slice(insertPos);
}

// Inject \\pdfmapfile commands for font map files
function injectPdfMapFileCommands(source, mapFilePaths) {
    if (mapFilePaths.length === 0) return source;

    // Filter out map files already in the source
    const newMaps = mapFilePaths.filter(p => !source.includes(p));
    if (newMaps.length === 0) {
        workerLog('All ' + mapFilePaths.length + ' map files already in document, skipping injection');
        return source;
    }

    // Build \\pdfmapfile commands - use + prefix to add to existing maps
    const mapCommands = newMaps.map(p => '\\\\pdfmapfile{+' + p + '}').join('\\n');

    // Find injection point - prefer after \\documentclass, fallback to after \\begin{document}
    // This handles both normal documents and custom format documents (which start at \\begin{document})
    const documentclassMatch = source.match(/\\\\documentclass(\\[[^\\]]*\\])?\\{[^}]+\\}/);
    const beginDocMatch = source.match(/\\\\begin\\{document\\}/);

    let insertPos, insertLabel;
    if (documentclassMatch) {
        insertPos = documentclassMatch.index + documentclassMatch[0].length;
        insertLabel = 'after \\\\documentclass';
    } else if (beginDocMatch) {
        insertPos = beginDocMatch.index + beginDocMatch[0].length;
        insertLabel = 'after \\\\begin{document}';
    } else {
        workerLog('Warning: Could not find \\\\documentclass or \\\\begin{document} to inject \\\\pdfmapfile');
        return source;
    }

    const preambleInsert = '\\n% Font maps injected by Siglum for cm-super support\\n' + mapCommands + '\\n';

    workerLog('Injecting ' + newMaps.length + ' \\\\pdfmapfile commands ' + insertLabel + ':');
    for (const p of newMaps) {
        workerLog('  \\\\pdfmapfile{+' + p + '}');
    }
    return source.slice(0, insertPos) + preambleInsert + source.slice(insertPos);
}

// Generate ls-R database from manifest (optimized - no FS tree walking)
function generateLsR(FS, basePath) {
    // Build directory structure - use arrays instead of Sets for faster iteration
    const dirContents = new Map();  // dir -> { files: [], subdirs: [] }
    const seenDirs = new Set();     // Track directories we've already registered

    // Ensure base path entry exists
    dirContents.set(basePath, { files: [], subdirs: [] });

    // Helper to get or create directory entry
    function getDir(dirPath) {
        if (!dirContents.has(dirPath)) {
            dirContents.set(dirPath, { files: [], subdirs: [] });
        }
        return dirContents.get(dirPath);
    }

    // Helper to ensure directory chain exists
    function ensureDirChain(dirPath) {
        if (seenDirs.has(dirPath) || dirPath.length <= basePath.length) return;
        seenDirs.add(dirPath);

        getDir(dirPath);  // Ensure this dir exists

        // Register with parent
        const parentSlash = dirPath.lastIndexOf('/');
        if (parentSlash > basePath.length) {
            const parentDir = dirPath.substring(0, parentSlash);
            const subdir = dirPath.substring(parentSlash + 1);
            ensureDirChain(parentDir);  // Ensure parent exists first
            getDir(parentDir).subdirs.push(subdir);
        } else if (parentSlash >= 0) {
            // Direct child of basePath
            const subdir = dirPath.substring(parentSlash + 1);
            getDir(basePath).subdirs.push(subdir);
        }
    }

    // Process all manifest files
    for (const path of Object.keys(fileManifest)) {
        if (!path.startsWith(basePath)) continue;
        const lastSlash = path.lastIndexOf('/');
        if (lastSlash < 0) continue;  // Skip malformed paths
        const dirPath = path.substring(0, lastSlash);
        const fileName = path.substring(lastSlash + 1);
        if (!dirPath || !fileName) continue;  // Skip empty

        ensureDirChain(dirPath);
        const dir = getDir(dirPath);
        if (dir && dir.files) dir.files.push(fileName);
    }

    // Add CTAN-mounted files
    for (const path of ctanMountedFiles) {
        if (!path.startsWith(basePath)) continue;
        const lastSlash = path.lastIndexOf('/');
        if (lastSlash < 0) continue;  // Skip malformed paths
        const dirPath = path.substring(0, lastSlash);
        const fileName = path.substring(lastSlash + 1);
        if (!dirPath || !fileName) continue;  // Skip empty

        ensureDirChain(dirPath);
        const dir = getDir(dirPath);
        if (dir && dir.files) dir.files.push(fileName);
    }

    // Build output - sort once per directory
    const output = ['% ls-R -- filename database.', '% Created by Siglum worker', ''];

    function outputDir(dirPath) {
        const contents = dirContents.get(dirPath);
        if (!contents) return;

        output.push(dirPath + ':');

        // Sort once, then output files and subdirs
        contents.files.sort();
        contents.subdirs.sort();

        for (const file of contents.files) output.push(file);
        for (const subdir of contents.subdirs) output.push(subdir);
        output.push('');

        // Recurse (already sorted)
        for (const subdir of contents.subdirs) {
            outputDir(dirPath + '/' + subdir);
        }
    }

    outputDir(basePath);
    return output.join(String.fromCharCode(10));
}

// Mount bundle lazily - optimized version
// Expects manifest to be pre-indexed by bundle (bundleFilesMap)
function mountBundleLazy(FS, bundleName, bundleData, manifest, bundleFilesMap) {
    if (mountedBundles.has(bundleName)) return 0;

    // Store in cache for lazy loading
    bundleCache.set(bundleName, bundleData);

    const MEMFS = FS.filesystems.MEMFS;

    // Get files for this bundle - use pre-indexed map if available, else filter
    let bundleFiles;
    if (bundleFilesMap && bundleFilesMap.has(bundleName)) {
        bundleFiles = bundleFilesMap.get(bundleName);
    } else {
        // Fallback: filter manifest (slower)
        bundleFiles = [];
        for (const [path, info] of Object.entries(manifest)) {
            if (info.bundle === bundleName) {
                bundleFiles.push([path, info]);
            }
        }
    }

    // Phase 1: Collect all unique directories and create them
    const directories = new Set();
    for (const [filePath] of bundleFiles) {
        const lastSlash = filePath.lastIndexOf('/');
        if (lastSlash > 0) {
            directories.add(filePath.substring(0, lastSlash));
        }
    }
    for (const dirPath of directories) {
        ensureDirectory(FS, dirPath);
    }

    // Phase 2: Cache all parent nodes
    const parentCache = new Map();
    for (const dirPath of directories) {
        try {
            parentCache.set(dirPath, FS.lookupPath(dirPath).node);
        } catch (e) {}
    }

    // Phase 3: Create all file nodes
    let mounted = 0;
    for (const [filePath, info] of bundleFiles) {
        const lastSlash = filePath.lastIndexOf('/');
        const dirPath = filePath.substring(0, lastSlash);
        const fileName = filePath.substring(lastSlash + 1);

        try {
            const parentNode = parentCache.get(dirPath);
            if (!parentNode) continue;

            // Skip if file already exists in parent
            if (parentNode.contents && parentNode.contents[fileName]) continue;

            if (shouldEagerLoad(filePath)) {
                // Eager load: write full content
                const content = new Uint8Array(bundleData.slice(info.start, info.end));
                FS.writeFile(filePath, content);
                // Debug: log eagerly loaded files
                if (filePath.includes('pdftex.map') || filePath.endsWith('.fmt')) {
                    workerLog('EAGER: ' + filePath + ' (' + content.length + ' bytes)');
                }
            } else {
                // Lazy load: Create node directly
                const node = MEMFS.createNode(parentNode, fileName, 33206, 0);
                node.contents = createLazyMarker(bundleName, info.start, info.end);
                node.usedBytes = info.end - info.start;
            }
            mounted++;
        } catch (e) {
            // Ignore errors for individual files
        }
    }

    mountedBundles.add(bundleName);
    return mounted;
}

// Mount bundle eagerly (all contents at once)
function mountBundleEager(FS, bundleName, bundleData, manifest) {
    if (mountedBundles.has(bundleName)) return 0;

    let mounted = 0;
    for (const [filePath, info] of Object.entries(manifest)) {
        if (info.bundle !== bundleName) continue;

        const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
        ensureDirectory(FS, dirPath);

        try {
            try {
                FS.stat(filePath);
                continue;  // Already exists
            } catch (e) {}

            const content = new Uint8Array(bundleData.slice(info.start, info.end));
            FS.writeFile(filePath, content);
            mounted++;
        } catch (e) {}
    }

    mountedBundles.add(bundleName);
    return mounted;
}

// Collect aux files from FS
function collectAuxFiles(FS) {
    const auxExtensions = ['.aux', '.toc', '.lof', '.lot', '.out', '.nav', '.snm', '.bbl', '.blg'];
    const files = {};

    for (const ext of auxExtensions) {
        const path = '/document' + ext;
        try {
            const content = FS.readFile(path, { encoding: 'utf8' });
            files[ext] = content;
        } catch (e) {}
    }

    return files;
}

// Restore aux files to FS
function restoreAuxFiles(FS, auxFiles) {
    let restored = 0;
    for (const [ext, content] of Object.entries(auxFiles)) {
        const path = '/document' + ext;
        try {
            FS.writeFile(path, content);
            restored++;
        } catch (e) {}
    }
    return restored;
}

// Extract missing file from TeX log, skipping already-fetched packages
function extractMissingFile(logContent, alreadyFetched) {
    // Pattern: ! LaTeX Error: File \`foo.sty' not found.
    // Also match font errors for EC/TC fonts that need cm-super
    // NOTE: Use new RegExp() with escaped backslashes since this is inside a template literal
    const patterns = [
        new RegExp("! LaTeX Error: File \\\`([^']+)' not found", 'g'),
        new RegExp("! I can't find file \\\`([^']+)'", 'g'),
        new RegExp("LaTeX Warning:.*File \\\`([^']+)' not found", 'g'),
        new RegExp("Package .* Error:.*\\\`([^']+)' not found", 'g'),
        // Font TFM errors - extract font name from TS1/cmr/m/n/10=tcrm1000
        new RegExp("! Font [^=]+=([a-z0-9]+) at .* not loadable: Metric \\\\(TFM\\\\) file", 'g'),
        // pdfTeX Type1 font missing - "!pdfTeX error: ... (file ecbi1000): Font ecbi1000 at 600 not found"
        new RegExp("!pdfTeX error:.*\\\\(file ([a-z0-9]+)\\\\): Font .* not found", 'g'),
        // Alternative format - "! Font ecbi1000 at 600 not found."
        new RegExp("! Font ([a-z]+[0-9]+) at [0-9]+ not found", 'g'),
    ];

    const fetchedSet = alreadyFetched || new Set();

    // Find ALL matches across all patterns, return first unfetched one
    for (let i = 0; i < patterns.length; i++) {
        const pattern = patterns[i];
        let match;
        while ((match = pattern.exec(logContent)) !== null) {
            const missingFile = match[1];
            const pkgName = getPackageFromFile(missingFile);
            if (!fetchedSet.has(pkgName)) {
                return missingFile;
            }
        }
    }
    return null;
}

// Map font names to packages that provide them
// EC/TC fonts (ecrm, ecbi, tcrm, etc.) are provided by cm-super
function getFontPackage(fontName) {
    // EC fonts (T1 encoding): ecrm, ecbx, ecti, ecbi, etc.
    // TC fonts (TS1 encoding): tcrm, tcbx, tcti, etc.
    const ecTcPattern = new RegExp('^(ec|tc)[a-z]{2}\\\\d+$');
    if (ecTcPattern.test(fontName)) {
        return 'cm-super';
    }
    return null;
}

// Get package name from file
function getPackageFromFile(filename) {
    // Check if it's a font name first
    const fontPkg = getFontPackage(filename);
    if (fontPkg) return fontPkg;

    // Remove extension
    // NOTE: In template literal -> RegExp: need 4 backslashes to get 1 in final regex
    // File \\\\. -> template \\. -> RegExp \. (literal dot)
    const extPattern = new RegExp('\\\\.(sty|cls|def|clo|fd|cfg|tex)$');
    const name = filename.replace(extPattern, '');
    return name;
}

// Copy .enc files from fonts/type1/ to fonts/enc/ where kpathsea expects them
function copyEncFilesToStandardLocation(FS, files) {
    const ENC_STANDARD_BASE = '/texlive/texmf-dist/fonts/enc/dvips';
    const encInType1 = Object.keys(files).filter(path =>
        path.endsWith('.enc') && path.includes('/fonts/type1/')
    );
    if (encInType1.length === 0) return;

    let copied = 0;
    for (const srcPath of encInType1) {
        try {
            const match = srcPath.match(new RegExp('/fonts/type1/public/([^/]+)/'));
            if (!match) continue;
            const pkgName = match[1];
            const fileName = srcPath.split('/').pop();
            const destDir = ENC_STANDARD_BASE + '/' + pkgName;
            const destPath = destDir + '/' + fileName;
            ensureDirectory(FS, destDir);
            const content = FS.readFile(srcPath);
            FS.writeFile(destPath, content);
            ctanMountedFiles.add(destPath);
            copied++;
        } catch (e) {}
    }
    if (copied > 0) workerLog('Copied ' + copied + ' .enc files to standard location');
}

// Rewrite font map file references to use absolute paths
// This is critical because kpathsea doesn't work reliably in WASM
function rewriteMapWithAbsolutePaths(FS, mapContent, mapFilePath) {
    const lines = mapContent.split(String.fromCharCode(10));
    const rewrittenLines = [];

    // Get package name from map file path (e.g., cm-super from cm-super-t1.map)
    const mapDir = mapFilePath.substring(0, mapFilePath.lastIndexOf('/'));
    const packageName = mapFilePath.includes('/cm-super') ? 'cm-super' :
                       (mapFilePath.match(/\\/([^\\/]+)\\/[^\\/]+\\.map$/) || [])[1] || '';

    // Search paths for font files (.pfb) and encoding files (.enc)
    const searchPaths = {
        pfb: [
            '/texlive/texmf-dist/fonts/type1/public/' + packageName,
            '/texlive/texmf-dist/fonts/type1/public/cm-super',
            mapDir
        ],
        enc: [
            '/texlive/texmf-dist/fonts/enc/dvips/' + packageName,
            '/texlive/texmf-dist/fonts/enc/dvips/cm-super',
            '/texlive/texmf-dist/fonts/type1/public/' + packageName,
            '/texlive/texmf-dist/fonts/type1/public/cm-super',
            mapDir
        ]
    };

    for (const line of lines) {
        // Skip comments and empty lines
        if (line.trim().startsWith('%') || line.trim() === '') {
            rewrittenLines.push(line);
            continue;
        }

        let rewrittenLine = line;

        // Find all file references like <filename.pfb or <filename.enc or <<filename.pfb
        // Pattern matches: < or << followed by filename.ext
        const fileRefPattern = /<<?([a-zA-Z0-9_-]+\\.(pfb|enc))/g;
        let match;
        while ((match = fileRefPattern.exec(line)) !== null) {
            const fullMatch = match[0];  // e.g., "<sfbi1000.pfb" or "<<sfbi1000.pfb"
            const filename = match[1];   // e.g., "sfbi1000.pfb"
            const ext = match[2];        // e.g., "pfb" or "enc"
            const prefix = fullMatch.startsWith('<<') ? '<<' : '<';

            // Search for the file in known paths
            const paths = searchPaths[ext] || [];
            let absolutePath = null;

            for (const searchDir of paths) {
                const candidatePath = searchDir + '/' + filename;
                try {
                    if (FS.analyzePath(candidatePath).exists) {
                        absolutePath = candidatePath;
                        break;
                    }
                } catch (e) {}
            }

            if (absolutePath) {
                // Replace bare filename with absolute path
                rewrittenLine = rewrittenLine.replace(fullMatch, prefix + absolutePath);
            }
        }

        rewrittenLines.push(rewrittenLine);
    }

    return rewrittenLines.join(String.fromCharCode(10));
}

// Append font map entries to pdftex.map for cm-super fonts
function appendFontMapsToUpdmap(FS, files) {
    const PDFTEX_MAP_PATH = '/texlive/texmf-dist/texmf-var/fonts/map/pdftex/updmap/pdftex.map';
    const NL = String.fromCharCode(10);  // Actual newline character
    const mapFiles = Object.keys(files).filter(p => p.endsWith('.map') && !p.endsWith('pdftex.map'));
    if (mapFiles.length === 0) {
        workerLog('appendFontMapsToUpdmap: no .map files found in ' + Object.keys(files).length + ' files');
        return;
    }

    workerLog('appendFontMapsToUpdmap: found ' + mapFiles.length + ' map files: ' + mapFiles.join(', '));

    let existingMap = '';
    try {
        existingMap = new TextDecoder().decode(FS.readFile(PDFTEX_MAP_PATH));
        workerLog('appendFontMapsToUpdmap: existing pdftex.map size=' + existingMap.length);
    } catch (e) {
        workerLog('appendFontMapsToUpdmap: pdftex.map not found, creating new');
        ensureDirectory(FS, PDFTEX_MAP_PATH.substring(0, PDFTEX_MAP_PATH.lastIndexOf('/')));
    }

    let appended = 0;
    for (const mapPath of mapFiles) {
        try {
            const mapContent = new TextDecoder().decode(FS.readFile(mapPath));
            // Rewrite paths to absolute before appending
            const rewrittenContent = rewriteMapWithAbsolutePaths(FS, mapContent, mapPath);
            existingMap += NL + '% Added from ' + mapPath + ' (with absolute paths)' + NL + rewrittenContent + NL;
            appended++;

            // Debug: show a sample rewritten entry
            const ecbiEntry = rewrittenContent.split(NL).find(l => l.startsWith('ecbi1000'));
            if (ecbiEntry) {
                workerLog('appendFontMapsToUpdmap: sample ecbi1000 entry: ' + ecbiEntry);
            }
            workerLog('appendFontMapsToUpdmap: added ' + mapPath + ' (' + mapContent.length + ' -> ' + rewrittenContent.length + ' chars)');
        } catch (e) {
            workerLog('appendFontMapsToUpdmap: failed to read ' + mapPath + ': ' + e.message);
        }
    }

    if (appended > 0) {
        FS.writeFile(PDFTEX_MAP_PATH, existingMap);
        workerLog('Appended ' + appended + ' font map files to pdftex.map (new size=' + existingMap.length + ')');
    }
}

// Initialize WASM from transferred module
async function initBusyTeX(wasmModule, busytexJsUrl) {
    workerLog('Initializing WASM in worker...');
    const startTime = performance.now();

    // Import the BusyTeX wrapper (need absolute URL in worker)
    importScripts(busytexJsUrl);

    // Create module configuration (matching main thread's initBusyTeX)
    const moduleConfig = {
        thisProgram: '/bin/busytex',
        noInitialRun: true,
        noExitRuntime: true,
        instantiateWasm: (imports, successCallback) => {
            WebAssembly.instantiate(wasmModule, imports).then(instance => {
                successCallback(instance);
            });
            return {};
        },
        print: (text) => workerLog('[TeX] ' + text),
        printErr: (text) => workerLog('[TeX ERR] ' + text),
        locateFile: (path) => path,
        // Set environment before program runs (preRun is called by Emscripten before main)
        preRun: [function() {
            moduleConfig.ENV = moduleConfig.ENV || {};
            moduleConfig.ENV['TEXMFCNF'] = '/texlive/texmf-dist/web2c';
            moduleConfig.ENV['TEXMFROOT'] = '/texlive';
            moduleConfig.ENV['TEXMFDIST'] = '/texlive/texmf-dist';
            moduleConfig.ENV['TEXMFVAR'] = '/texlive/texmf-dist/texmf-var';
            moduleConfig.ENV['TEXMFSYSVAR'] = '/texlive/texmf-dist/texmf-var';
            moduleConfig.ENV['TEXMF'] = '/texlive/texmf-dist';
            moduleConfig.ENV['TEXINPUTS'] = '.:/texlive/texmf-dist/tex/latex//:/texlive/texmf-dist/tex/xetex//:/texlive/texmf-dist/tex/generic//:/texlive/texmf-dist/tex//:';
            moduleConfig.ENV['T1FONTS'] = '.:/texlive/texmf-dist/fonts/type1/public/cm-super:/texlive/texmf-dist/fonts/type1//';
            moduleConfig.ENV['ENCFONTS'] = '.:/texlive/texmf-dist/fonts/enc/dvips/cm-super:/texlive/texmf-dist/fonts/type1/public/cm-super:/texlive/texmf-dist/fonts/enc//';
        }],
    };

    // Initialize BusyTeX (note: exported as lowercase 'busytex')
    const Module = await busytex(moduleConfig);

    // Create /bin directory and dummy busytex file for kpathsea
    const FS = Module.FS;
    try { FS.mkdir('/bin'); } catch (e) {}
    try { FS.writeFile('/bin/busytex', ''); } catch (e) {}

    // Add helper methods (matching main thread's Module)
    Module.setPrefix = function(prefix) {
        Module.thisProgram = '/bin/' + prefix;
    };

    Module.callMainWithRedirects = function(args = [], print = false) {
        Module.do_print = print;
        Module.output_stdout = '';
        Module.output_stderr = '';
        if (args.length > 0) Module.setPrefix(args[0]);
        const exit_code = Module.callMain(args);
        Module._flush_streams();
        return { exit_code, stdout: Module.output_stdout, stderr: Module.output_stderr };
    };

    const elapsed = performance.now() - startTime;
    workerLog('WASM initialized in ' + elapsed.toFixed(0) + 'ms');

    return Module;
}

// Handle compile request
async function handleCompile(request) {
    const {
        id, source, engine, options,
        bundleData, ctanFiles, cachedFormat, cachedAuxFiles
    } = request;

    workerLog('=== COMPILE v6 (base font maps always) ===');  // Version marker to confirm new code

    workerLog('=== Worker Compilation Started ===');
    const totalStart = performance.now();

    // Reset per-compile state
    mountedBundles.clear();
    dirNodeCache.clear();
    ctanMountedFiles.clear();
    lazyLoadCount = 0;

    // Static data (manifest, packageMap, etc.) was received during init
    // Just validate it's present
    if (!fileManifest) {
        throw new Error('fileManifest not set - was init message sent?');
    }

    try {
        workerProgress('init', 'Initializing WASM...');
        let Module = await initBusyTeX(cachedWasmModule, busytexJsUrl);
        let FS = Module.FS;

        // Patch MEMFS to support lazy content resolution (must be done before mounting)
        if (options.enableLazyFS) {
            patchMEMFSForLazyLoading(FS);
        }

        workerProgress('mount', 'Mounting bundles...');

        // Convert bundleData from object to Map if needed
        const bundleDataMap = bundleData instanceof Map ? bundleData : new Map(Object.entries(bundleData));

        // Use cached bundle files map if manifest hasn't changed
        // Check by entry count since manifest is cloned on each postMessage
        const manifestSize = Object.keys(fileManifest).length;
        if (!cachedBundleFilesMap || cachedManifestSize !== manifestSize) {
            const indexStart = performance.now();
            cachedBundleFilesMap = new Map();
            for (const [path, info] of Object.entries(fileManifest)) {
                if (!cachedBundleFilesMap.has(info.bundle)) {
                    cachedBundleFilesMap.set(info.bundle, []);
                }
                cachedBundleFilesMap.get(info.bundle).push([path, info]);
            }
            cachedManifestSize = manifestSize;
            workerLog('Indexed ' + manifestSize + ' manifest entries in ' + (performance.now() - indexStart).toFixed(0) + 'ms');
        }
        const bundleFilesMap = cachedBundleFilesMap;

        // Mount bundles
        const mountStart = performance.now();
        let totalMounted = 0;
        // Debug: log bundle names being mounted
        workerLog('Bundles to mount: ' + Array.from(bundleDataMap.keys()).join(', '));
        for (const [bundleName, data] of bundleDataMap) {
            if (options.enableLazyFS) {
                totalMounted += mountBundleLazy(FS, bundleName, data, fileManifest, bundleFilesMap);
            } else {
                totalMounted += mountBundleEager(FS, bundleName, data, fileManifest);
            }
        }
        workerLog('Mounted ' + totalMounted + ' files from ' + bundleDataMap.size + ' bundles in ' + (performance.now() - mountStart).toFixed(0) + 'ms');

        // Mount CTAN files from cache
        let ctanMounted = 0;
        const ctanFileObj = {};  // Track paths for font map processing
        if (ctanFiles) {
            const ctanFilesMap = ctanFiles instanceof Map ? ctanFiles : new Map(Object.entries(ctanFiles));
            for (const [filePath, content] of ctanFilesMap) {
                if (fileManifest[filePath]) continue;  // Skip if in bundle
                const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                ensureDirectory(FS, dirPath);
                try {
                    FS.writeFile(filePath, content);
                    ctanMountedFiles.add(filePath);
                    ctanFileObj[filePath] = true;
                    ctanMounted++;
                } catch (e) {}
            }
        }
        if (ctanMounted > 0) {
            workerLog('Mounted ' + ctanMounted + ' CTAN files');
            // Append font map entries to pdftex.map (critical for cm-super fonts)
            appendFontMapsToUpdmap(FS, ctanFileObj);
            // Copy .enc files to standard location
            copyEncFilesToStandardLocation(FS, ctanFileObj);
        }

        // Restore aux files if provided
        if (cachedAuxFiles && Object.keys(cachedAuxFiles).length > 0) {
            const restored = restoreAuxFiles(FS, cachedAuxFiles);
            if (restored > 0) workerLog('Restored ' + restored + ' aux files');
        }

        // Generate ls-R
        const lsRStart = performance.now();
        const lsRContent = generateLsR(FS, '/texlive/texmf-dist');
        FS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);
        workerLog('Generated ls-R in ' + (performance.now() - lsRStart).toFixed(0) + 'ms');

        // Determine format path
        let fmtPath = engine === 'pdflatex'
            ? '/texlive/texmf-dist/texmf-var/web2c/pdftex/pdflatex.fmt'
            : '/texlive/texmf-dist/texmf-var/web2c/xetex/xelatex.fmt';

        // Use custom format if provided
        let docSource = source;
        if (cachedFormat && engine === 'pdflatex') {
            FS.writeFile('/custom.fmt', cachedFormat.fmtData);
            fmtPath = '/custom.fmt';
            workerLog('Using custom format');

            // Strip preamble - the format already has it baked in
            // Only keep content from \begin{document} onwards
            // Try multiple variations to handle whitespace
            const bs = String.fromCharCode(92);  // backslash
            const variations = [
                bs + 'begin{document}',
                bs + 'begin{ document}',
                bs + 'begin{document }',
                bs + 'begin{ document }'
            ];
            let beginDocIdx = -1;
            let matchedVariation = '';
            for (const v of variations) {
                const idx = source.indexOf(v);
                if (idx !== -1 && (beginDocIdx === -1 || idx < beginDocIdx)) {
                    beginDocIdx = idx;
                    matchedVariation = v;
                }
            }
            if (beginDocIdx !== -1) {
                docSource = source.substring(beginDocIdx);
            }
        }

        // Apply pdflatex workarounds
        if (engine === 'pdflatex') {
            // Disable microtype font expansion - only when not using custom format
            // (custom format has this baked in)
            if (!cachedFormat) {
                docSource = injectMicrotypeWorkaround(docSource);
            }

            // Inject base CM font maps for pdflatex
            // This is ALWAYS needed because font map loading happens at runtime
            const baseMaps = [
                '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cm.map',
                '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cmextra.map',
                '/texlive/texmf-dist/fonts/map/dvips/amsfonts/symbols.map',
                '/texlive/texmf-dist/fonts/map/dvips/amsfonts/euler.map',
                '/texlive/texmf-dist/fonts/map/dvips/amsfonts/latxfont.map',
            ];
            const existingMaps = baseMaps.filter(m => FS.analyzePath(m).exists);
            if (existingMaps.length > 0) {
                docSource = injectPdfMapFileCommands(docSource, existingMaps);
                // Also rewrite and append to pdftex.map (for safety)
                const baseMapsObj = {};
                for (const m of existingMaps) baseMapsObj[m] = true;
                appendFontMapsToUpdmap(FS, baseMapsObj);
            }
        }

        // Write source
        FS.writeFile('/document.tex', docSource);

        workerProgress('compile', 'Running ' + engine + '...');

        // Compile with retry loop for missing packages
        let pdfData = null;
        let compileSuccess = false;
        let retryCount = 0;
        const maxRetries = 10;
        const ctanFetched = new Set();
        let lastExitCode = -1;

        // Track accumulated CTAN files for remounting on retry
        const accumulatedCtanFiles = new Map();
        if (ctanFiles) {
            const ctanFilesMap = ctanFiles instanceof Map ? ctanFiles : new Map(Object.entries(ctanFiles));
            for (const [path, content] of ctanFilesMap) {
                accumulatedCtanFiles.set(path, content);
            }
        }

        while (!compileSuccess && retryCount < maxRetries) {
            if (retryCount > 0) {
                workerLog('Retry #' + retryCount + '...');
                // For retries, we need fresh WASM (TeX corrupts its state on failure)
                // Reinitialize everything
                workerProgress('init', 'Reinitializing WASM for retry...');
                Module = await initBusyTeX(cachedWasmModule, busytexJsUrl);
                FS = Module.FS;

                // Re-patch MEMFS for lazy loading (new WASM instance needs fresh patching)
                if (options.enableLazyFS) {
                    patchMEMFSForLazyLoading(FS);
                }

                // Re-mount bundles
                mountedBundles.clear();
                dirNodeCache.clear();
                bundleCache.clear();  // Clear lazy loading cache too
                let retryMounted = 0;
                for (const [bundleName, data] of bundleDataMap) {
                    if (options.enableLazyFS) {
                        retryMounted += mountBundleLazy(FS, bundleName, data, fileManifest);
                    } else {
                        retryMounted += mountBundleEager(FS, bundleName, data, fileManifest);
                    }
                }
                workerLog('Re-mounted ' + retryMounted + ' files from ' + bundleDataMap.size + ' bundles');

                // Re-mount accumulated CTAN files
                ctanMountedFiles.clear();
                const ctanFileObj = {};  // For appendFontMapsToUpdmap
                for (const [path, content] of accumulatedCtanFiles) {
                    if (fileManifest[path]) continue;
                    const dir = path.substring(0, path.lastIndexOf('/'));
                    ensureDirectory(FS, dir);
                    try {
                        FS.writeFile(path, content);
                        ctanMountedFiles.add(path);
                        ctanFileObj[path] = true;
                    } catch (e) {}
                }
                const mapFilesInObj = Object.keys(ctanFileObj).filter(p => p.endsWith('.map'));

                // Append font map entries to pdftex.map (critical for cm-super fonts)
                appendFontMapsToUpdmap(FS, ctanFileObj);

                // Copy .enc files to standard location
                copyEncFilesToStandardLocation(FS, ctanFileObj);

                // Restore aux files
                if (cachedAuxFiles && Object.keys(cachedAuxFiles).length > 0) {
                    restoreAuxFiles(FS, cachedAuxFiles);
                }

                // Regenerate ls-R
                const newLsR = generateLsR(FS, '/texlive/texmf-dist');
                FS.writeFile('/texlive/texmf-dist/ls-R', newLsR);

                // Re-write custom format file if using one
                if (cachedFormat && fmtPath === '/custom.fmt') {
                    FS.writeFile('/custom.fmt', cachedFormat.fmtData);
                    workerLog('Re-wrote custom format file for retry');
                }

                // Inject \pdfmapfile commands for newly added CTAN font maps
                // This is critical because pdfTeX caches pdftex.map at startup
                // \pdfmapfile loads maps at runtime, bypassing the cache
                if (mapFilesInObj.length > 0 && engine === 'pdflatex') {
                    workerLog('Injecting ' + mapFilesInObj.length + ' \\pdfmapfile commands for CTAN font maps');
                    docSource = injectPdfMapFileCommands(docSource, mapFilesInObj);
                }

                // Re-write document (use docSource which has workarounds applied)
                FS.writeFile('/document.tex', docSource);
            }

            // Run compilation
            let result;
            if (engine === 'pdflatex') {
                result = Module.callMainWithRedirects([
                    'pdflatex',
                    '--no-shell-escape',
                    '--interaction=nonstopmode',
                    '--halt-on-error',
                    '--fmt=' + fmtPath,
                    '/document.tex'
                ]);
            } else {
                // XeLaTeX: first create XDV, then convert to PDF
                result = Module.callMainWithRedirects([
                    'xelatex',
                    '--no-shell-escape',
                    '--interaction=nonstopmode',
                    '--halt-on-error',
                    '--no-pdf',
                    '--fmt=/texlive/texmf-dist/texmf-var/web2c/xetex/xelatex.fmt',
                    '/document.tex'
                ]);

                if (result.exit_code === 0) {
                    // Convert XDV to PDF
                    workerProgress('convert', 'Converting to PDF...');
                    result = Module.callMainWithRedirects([
                        'xdvipdfmx',
                        '-o', '/document.pdf',
                        '/document.xdv'
                    ]);
                }
            }

            lastExitCode = result.exit_code;

            if (result.exit_code === 0) {
                try {
                    pdfData = FS.readFile('/document.pdf');
                    compileSuccess = true;
                    workerLog('Compilation successful!');
                } catch (e) {
                    workerLog('PDF not found after successful exit');
                }
            }

            // If failed and CTAN enabled, try to fetch missing package
            if (!compileSuccess && options.enableCtan) {
                let logContent = '';
                try {
                    logContent = new TextDecoder().decode(FS.readFile('/document.log'));
                } catch (e) {}

                // Also check stdout/stderr - pdfTeX sometimes writes fatal errors there before flushing log
                const allOutput = logContent + ' ' + (result.stdout || '') + ' ' + (result.stderr || '');

                // extractMissingFile now skips already-fetched packages automatically
                const missingFile = extractMissingFile(allOutput, ctanFetched);
                if (missingFile) {
                    const pkgName = getPackageFromFile(missingFile);
                    workerLog('Missing: ' + missingFile + ', fetching ' + pkgName + ' from CTAN...');

                    try {
                        const ctanData = await requestCtanFetch(pkgName);
                        if (ctanData.success) {
                            ctanFetched.add(pkgName);
                            // Mount files and accumulate for future retries
                            const files = ctanData.files instanceof Map ? ctanData.files : new Map(Object.entries(ctanData.files));
                            for (const [path, content] of files) {
                                accumulatedCtanFiles.set(path, content);  // Save for retry remount
                            }
                            retryCount++;
                            continue;  // Will reinit WASM and remount all on next iteration
                        }
                    } catch (e) {
                        workerLog('CTAN fetch failed: ' + e.message);
                    }
                }
                break;  // Can't recover
            } else if (!compileSuccess) {
                break;
            }
        }

        // Collect aux files for caching
        const auxFiles = compileSuccess ? collectAuxFiles(FS) : null;

        const totalTime = performance.now() - totalStart;
        workerLog('Total time: ' + totalTime.toFixed(0) + 'ms');

        // Send response
        const transferables = pdfData ? [pdfData.buffer] : [];
        self.postMessage({
            type: 'compile-response',
            id,
            success: compileSuccess,
            pdfData: pdfData ? pdfData.buffer : null,
            exitCode: lastExitCode,
            auxFilesToCache: auxFiles,
            stats: {
                compileTimeMs: totalTime,
                lazyLoadCount: lazyLoadCount,
                bundlesUsed: [...bundleDataMap.keys()],
            }
        }, transferables);

    } catch (e) {
        workerLog('Error: ' + e.message);
        console.error(e);
        self.postMessage({
            type: 'compile-response',
            id,
            success: false,
            exitCode: -1,
            error: e.message,
        });
    }
}

// Handle format generation request
async function handleFormatGenerate(request) {
    const {
        id, preambleContent, engine, manifest, packageMapData, bundleDepsData,
        bundleRegistryData, bundleData, ctanFiles
    } = request;

    workerLog('=== Format Generation Started ===');
    const startTime = performance.now();

    // Reset state
    mountedBundles.clear();
    dirNodeCache.clear();
    ctanMountedFiles.clear();

    // Store manifest
    fileManifest = manifest;
    packageMap = packageMapData;
    bundleDeps = bundleDepsData;
    bundleRegistry = new Set(bundleRegistryData);

    try {
        const Module = await initBusyTeX(cachedWasmModule, busytexJsUrl);
        const FS = Module.FS;

        // Mount bundles
        const bundleDataMap = bundleData instanceof Map ? bundleData : new Map(Object.entries(bundleData));
        for (const [bundleName, data] of bundleDataMap) {
            mountBundleEager(FS, bundleName, data, fileManifest);
        }

        // Mount CTAN files
        if (ctanFiles) {
            const ctanFilesMap = ctanFiles instanceof Map ? ctanFiles : new Map(Object.entries(ctanFiles));
            for (const [filePath, content] of ctanFilesMap) {
                if (fileManifest[filePath]) continue;
                const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                ensureDirectory(FS, dirPath);
                try {
                    FS.writeFile(filePath, content);
                } catch (e) {}
            }
        }

        // Generate ls-R
        const lsRContent = generateLsR(FS, '/texlive/texmf-dist');
        FS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);

        // Create .ini file
        const iniContent = preambleContent + '\\n\\\\dump\\n';
        FS.writeFile('/myformat.ini', iniContent);

        // Run initex
        const result = Module.callMainWithRedirects([
            'pdflatex',
            '-ini',
            '-jobname=myformat',
            '-interaction=nonstopmode',
            '&/texlive/texmf-dist/texmf-var/web2c/pdftex/pdflatex',
            '/myformat.ini'
        ]);

        if (result.exit_code !== 0) {
            throw new Error('Format generation failed with exit code ' + result.exit_code);
        }

        const formatData = FS.readFile('/myformat.fmt');
        const elapsed = performance.now() - startTime;
        workerLog('Format generated: ' + (formatData.byteLength / 1024 / 1024).toFixed(1) + 'MB in ' + elapsed.toFixed(0) + 'ms');

        self.postMessage({
            type: 'format-generate-response',
            id,
            success: true,
            formatData: formatData.buffer,
        }, [formatData.buffer]);

    } catch (e) {
        workerLog('Format generation error: ' + e.message);
        self.postMessage({
            type: 'format-generate-response',
            id,
            success: false,
            error: e.message,
        });
    }
}

// Message handler
self.onmessage = async function(e) {
    const msg = e.data;

    switch (msg.type) {
        case 'init':
            cachedWasmModule = msg.wasmModule;
            busytexJsUrl = msg.busytexJsUrl;
            // Also receive static data (manifest, package map, etc.) during init
            if (msg.manifest) {
                fileManifest = msg.manifest;
                packageMap = msg.packageMapData;
                bundleDeps = msg.bundleDepsData;
                bundleRegistry = new Set(msg.bundleRegistryData || []);
                workerLog('Received static data: ' + Object.keys(fileManifest).length + ' manifest entries');
            }
            self.postMessage({ type: 'ready' });
            break;

        case 'compile':
            await handleCompile(msg);
            break;

        case 'generate-format':
            await handleFormatGenerate(msg);
            break;

        case 'ctan-fetch-response':
            const pending = pendingCtanRequests.get(msg.requestId);
            if (pending) {
                pendingCtanRequests.delete(msg.requestId);
                if (msg.success) {
                    pending.resolve(msg);
                } else {
                    pending.reject(new Error(msg.error || 'CTAN fetch failed'));
                }
            }
            break;
    }
};

self.onerror = function(e) {
    self.postMessage({ type: 'log', message: 'Worker error: ' + e.message });
};
`;
            return code;
        }

        // Initialize the compilation worker
        async function initCompilationWorker() {
            if (compilationWorker) return compilationWorker;

            log('Initializing compilation worker...');

            // Create worker from blob URL
            const workerCode = createWorkerCode();
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const workerUrl = URL.createObjectURL(blob);

            compilationWorker = new Worker(workerUrl);

            // Set up message handler
            compilationWorker.onmessage = handleWorkerMessage;
            compilationWorker.onerror = handleWorkerError;

            // Pre-compile WASM module if not already done
            if (!cachedWasmModule) {
                log('Pre-compiling WASM module...');
                const response = await fetch('busytex.wasm');
                const wasmBytes = await response.arrayBuffer();
                cachedWasmModule = await WebAssembly.compile(wasmBytes);
            }

            // Load static data to send with init (before Promise)
            await Promise.all([loadManifest(), loadBundleDeps()]);

            // Get absolute URL for busytex.js
            const busytexJsUrl = new URL('busytex.js', window.location.href).href;

            // Send init message with WASM module
            return new Promise((resolve, reject) => {
                const initTimeout = setTimeout(() => {
                    reject(new Error('Worker init timeout'));
                }, 30000);

                const originalHandler = compilationWorker.onmessage;
                compilationWorker.onmessage = (e) => {
                    if (e.data.type === 'ready') {
                        clearTimeout(initTimeout);
                        workerReady = true;
                        compilationWorker.onmessage = originalHandler;
                        log('Worker ready!');
                        resolve(compilationWorker);
                    } else {
                        originalHandler(e);
                    }
                };

                compilationWorker.postMessage({
                    type: 'init',
                    wasmModule: cachedWasmModule,
                    busytexJsUrl: busytexJsUrl,
                    // Send static data once during init (not on every compile)
                    manifest: fileManifest,
                    packageMapData: packageMap,
                    bundleDepsData: bundleDeps,
                    bundleRegistryData: bundleRegistry ? [...bundleRegistry] : [],
                });
            });
        }

        // Handle messages from worker
        function handleWorkerMessage(e) {
            const msg = e.data;

            switch (msg.type) {
                case 'log':
                    log(msg.message);
                    break;

                case 'progress':
                    // Could update a progress indicator
                    break;

                case 'compile-response':
                    if (msg.id === currentCompileId && pendingCompileResolve) {
                        pendingCompileResolve(msg);
                        pendingCompileResolve = null;
                        pendingCompileReject = null;
                        currentCompileId = null;
                    }
                    break;

                case 'format-generate-response':
                    handleFormatGenerateResponse(msg);
                    break;

                case 'ctan-fetch-request':
                    handleCtanFetchRequest(msg);
                    break;
            }
        }

        // Handle worker errors
        function handleWorkerError(e) {
            console.error('Worker error:', e);
            log('Worker error: ' + e.message);

            if (pendingCompileReject) {
                pendingCompileReject(new Error('Worker error: ' + e.message));
                pendingCompileResolve = null;
                pendingCompileReject = null;
                currentCompileId = null;
            }

            // Re-create worker on fatal error
            workerReady = false;
            compilationWorker = null;
        }

        // Handle CTAN fetch request from worker
        async function handleCtanFetchRequest(msg) {
            const { requestId, packageName } = msg;

            try {
                log('Worker requested CTAN package: ' + packageName);

                // Check cache first
                const cached = await loadPackageFromCache(packageName, null);
                if (cached && cached.files) {
                    // Package is cached, send files
                    const meta = await getPackageMeta(packageName);
                    const files = new Map();

                    if (meta && meta.files) {
                        for (const filePath of meta.files) {
                            const content = await readFromOPFS(filePath);
                            if (content) files.set(filePath, content);
                        }
                    }

                    compilationWorker.postMessage({
                        type: 'ctan-fetch-response',
                        requestId,
                        packageName,
                        success: true,
                        files: Object.fromEntries(files),
                        dependencies: meta?.dependencies || [],
                    });
                    return;
                }

                // Fetch from CTAN proxy
                const response = await fetch(CTAN_PROXY + '/api/fetch/' + packageName);
                if (!response.ok) {
                    throw new Error('CTAN fetch failed: ' + response.status);
                }

                const data = await response.json();
                if (data.error) {
                    throw new Error(data.error);
                }

                // Process and cache files
                const files = new Map();
                for (const [path, info] of Object.entries(data.files)) {
                    let content;
                    if (info.encoding === 'base64') {
                        const binary = atob(info.content);
                        content = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) {
                            content[i] = binary.charCodeAt(i);
                        }
                    } else if (typeof info.content === 'string') {
                        content = new TextEncoder().encode(info.content);
                    } else {
                        content = new Uint8Array(info.content);
                    }
                    files.set(path, content);

                    // Cache to OPFS
                    await writeToOPFS(path, content);
                    ctanMountedFiles.add(path);
                }

                // Cache metadata to IDB
                await savePackageMeta(packageName, {
                    name: packageName,
                    files: [...files.keys()],
                    dependencies: data.dependencies || [],
                    cacheVersion: CTAN_CACHE_VERSION,
                    timestamp: Date.now()
                });

                ctanFetchCount++;
                updateStats();

                // Send to worker
                compilationWorker.postMessage({
                    type: 'ctan-fetch-response',
                    requestId,
                    packageName,
                    success: true,
                    files: Object.fromEntries(files),
                    dependencies: data.dependencies || [],
                });

            } catch (e) {
                log('CTAN fetch error for ' + packageName + ': ' + e.message);
                compilationWorker.postMessage({
                    type: 'ctan-fetch-response',
                    requestId,
                    packageName,
                    success: false,
                    error: e.message,
                });
            }
        }

        // Handle format generation response
        function handleFormatGenerateResponse(msg) {
            if (msg.success && msg.formatData) {
                // Store in FormatGenerator
                const fmtData = new Uint8Array(msg.formatData);
                // The format key would need to be tracked
                log('Format generated in worker: ' + (fmtData.byteLength / 1024 / 1024).toFixed(1) + 'MB');
            } else {
                log('Format generation failed: ' + (msg.error || 'unknown error'));
            }
        }

        // Compile using worker
        async function compileWithWorker(source, engine, options = {}) {
            // Ensure worker is ready
            if (!compilationWorker || !workerReady) {
                await initCompilationWorker();
            }

            // Load manifests if needed
            if (!fileManifest) await loadManifest();
            if (!bundleDeps) await loadBundleDeps();

            // Determine bundles needed
            const { bundles } = checkPackages(source, engine);

            // Pre-load all bundle data
            const bundleData = {};
            // Note: We DON'T transfer ArrayBuffers because the worker may need them
            // for multiple retries (WASM reinit). Structured clone will copy them.

            for (const bundleName of bundles) {
                const data = await loadBundle(bundleName);
                if (data) {
                    // Create a copy (will be structured-cloned to worker)
                    bundleData[bundleName] = data.slice(0);
                }
            }

            // Pre-read CTAN files from OPFS
            const ctanFiles = {};
            for (const filePath of ctanMountedFiles) {
                const content = await readFromOPFS(filePath);
                if (content) ctanFiles[filePath] = content;
            }

            // Get cached format if available
            let cachedFormat = null;
            const preamble = extractPreambleContent(source);
            if (FormatGenerator.has(preamble, engine)) {
                const fmtKey = FormatGenerator.hashPreamble(preamble) + '_' + engine;
                const fmtData = FormatGenerator.formats.get(fmtKey);
                if (fmtData) {
                    cachedFormat = { fmtName: fmtKey, fmtData: new Uint8Array(fmtData) };
                }
            }

            // Get cached aux files
            const auxCache = await getAuxCache(getPreambleHashForAux(source));

            // Create compile request
            currentCompileId = crypto.randomUUID();

            return new Promise((resolve, reject) => {
                pendingCompileResolve = resolve;
                pendingCompileReject = reject;

                // Set timeout
                const timeout = setTimeout(() => {
                    if (pendingCompileReject) {
                        pendingCompileReject(new Error('Compilation timeout'));
                        pendingCompileResolve = null;
                        pendingCompileReject = null;
                        currentCompileId = null;
                    }
                }, 120000);  // 2 minute timeout

                // Wrap resolve to clear timeout
                const originalResolve = pendingCompileResolve;
                pendingCompileResolve = (result) => {
                    clearTimeout(timeout);
                    originalResolve(result);
                };

                // Static data (manifest, packageMap, etc.) was sent during init
                // Only send per-compile data here
                compilationWorker.postMessage({
                    type: 'compile',
                    id: currentCompileId,
                    source,
                    engine,
                    options: {
                        enableLazyFS: document.getElementById('enableLazyFS')?.checked ?? true,
                        enableCtan: document.getElementById('enableCtan')?.checked ?? true,
                    },
                    bundleData,
                    ctanFiles,
                    cachedFormat,
                    cachedAuxFiles: auxCache?.files || null,
                });  // No transferables - structured clone copies the data
            });
        }

        async function openIDBCache() {
            if (idbCache) return idbCache;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(IDB_NAME, 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    idbCache = request.result;
                    resolve(idbCache);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(IDB_STORE)) {
                        db.createObjectStore(IDB_STORE, { keyPath: 'name' });
                    }
                };
            });
        }

        async function getOPFSRoot() {
            if (opfsRoot) return opfsRoot;
            try {
                opfsRoot = await navigator.storage.getDirectory();
                return opfsRoot;
            } catch (e) {
                console.warn('OPFS not available:', e);
                return null;
            }
        }

        // Get package metadata from IndexedDB
        async function getPackageMeta(packageName) {
            try {
                const db = await openIDBCache();
                return new Promise((resolve) => {
                    const tx = db.transaction(IDB_STORE, 'readonly');
                    const store = tx.objectStore(IDB_STORE);
                    const request = store.get(packageName);
                    request.onerror = () => resolve(null);
                    request.onsuccess = () => resolve(request.result);
                });
            } catch (e) {
                return null;
            }
        }

        // Save package metadata to IndexedDB (files paths + dependencies)
        async function savePackageMeta(packageName, meta) {
            try {
                const db = await openIDBCache();
                return new Promise((resolve) => {
                    const tx = db.transaction(IDB_STORE, 'readwrite');
                    const store = tx.objectStore(IDB_STORE);
                    const request = store.put({ name: packageName, ...meta, timestamp: Date.now() });
                    request.onerror = () => resolve(false);
                    request.onsuccess = () => resolve(true);
                });
            } catch (e) {
                return false;
            }
        }

        // Clear all CTAN package cache (IDB + OPFS)
        // Call this when cached packages are causing compatibility issues
        async function clearCTANCache() {
            log('Clearing CTAN package cache...');
            try {
                // Clear IndexedDB
                const db = await openIDBCache();
                const tx = db.transaction(IDB_STORE, 'readwrite');
                const store = tx.objectStore(IDB_STORE);
                store.clear();
                await new Promise(r => tx.oncomplete = r);
                log('  Cleared IndexedDB package metadata');

                // Clear OPFS ctan-packages directory
                const root = await getOPFSRoot();
                if (root) {
                    try {
                        await root.removeEntry('ctan-packages', { recursive: true });
                        log('  Cleared OPFS ctan-packages');
                    } catch (e) {
                        // Directory might not exist
                    }
                }

                // Clear in-memory tracked files
                ctanMountedFiles.clear();
                log('CTAN cache cleared! Refresh page and recompile to re-fetch packages.');
                alert('CTAN cache cleared. Refresh the page and compile again.');
            } catch (e) {
                log('Error clearing cache: ' + e.message);
            }
        }
        // Export for button onclick
        window.clearCTANCache = clearCTANCache;

        // Test format file generation
        async function testFormatGeneration() {
            const source = document.getElementById('source').value;
            const preamble = extractPreambleContent(source);
            log('=== Format Generation Test ===');
            log(`Preamble (${preamble.length} chars):`);
            log(preamble.slice(0, 500) + (preamble.length > 500 ? '...' : ''));
            log('');

            // Clear existing format cache to force regeneration
            FormatGenerator.clear();
            log('Cleared format cache');
            log('Generating format file (this may take 30-60 seconds)...');

            const startTime = performance.now();
            try {
                const formatData = await FormatGenerator.generate(preamble, 'pdflatex');
                const elapsed = performance.now() - startTime;
                if (formatData) {
                    log(` Format generated: ${(formatData.byteLength / 1024 / 1024).toFixed(2)} MB in ${(elapsed / 1000).toFixed(1)}s`);
                    log('Format is cached and will be used for future compiles with this preamble.');
                } else {
                    log(' Format generation failed. Check browser console for details.');
                }
            } catch (e) {
                log(' Error: ' + e.message);
                console.error('Format generation error:', e);
            }
        }
        window.testFormatGeneration = testFormatGeneration;

        // Read file content from OPFS
        async function readFromOPFS(filePath) {
            try {
                const root = await getOPFSRoot();
                if (!root) return null;

                // Convert path like /texlive/texmf-dist/... to opfs path
                const parts = filePath.split('/').filter(p => p);
                let dir = root;
                for (let i = 0; i < parts.length - 1; i++) {
                    dir = await dir.getDirectoryHandle(parts[i], { create: false });
                }
                const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: false });
                const file = await fileHandle.getFile();
                return new Uint8Array(await file.arrayBuffer());
            } catch (e) {
                return null;  // File doesn't exist
            }
        }

        // Write file content to OPFS
        async function writeToOPFS(filePath, content) {
            try {
                const root = await getOPFSRoot();
                if (!root) return false;

                const parts = filePath.split('/').filter(p => p);
                let dir = root;
                for (let i = 0; i < parts.length - 1; i++) {
                    dir = await dir.getDirectoryHandle(parts[i], { create: true });
                }
                const fileHandle = await dir.getFileHandle(parts[parts.length - 1], { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(content);
                await writable.close();
                return true;
            } catch (e) {
                console.warn(`OPFS write failed for ${filePath}:`, e);
                return false;
            }
        }

        // ============================================================
        // BREAKTHROUGH: Aux File Caching for Faster Recompiles
        // ============================================================
        // Caches .aux, .toc, .bbl files between compiles with same preamble.
        // This allows TeX to skip regenerating cross-references, TOC, bibliography.
        // Expected improvement: 20-40% faster subsequent compiles.

        const AUX_CACHE_VERSION = 1;
        const AUX_STORE = 'aux-cache';
        let auxCacheDb = null;

        // In-memory cache for current session (much faster than IDB)
        const auxMemoryCache = new Map();

        async function openAuxCacheDb() {
            if (auxCacheDb) return auxCacheDb;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('siglum-aux-cache', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    auxCacheDb = request.result;
                    resolve(auxCacheDb);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(AUX_STORE)) {
                        db.createObjectStore(AUX_STORE, { keyPath: 'key' });
                    }
                };
            });
        }

        // Get aux cache for a preamble hash
        async function getAuxCache(preambleHash) {
            // Check memory cache first (instant)
            if (auxMemoryCache.has(preambleHash)) {
                return auxMemoryCache.get(preambleHash);
            }
            try {
                const db = await openAuxCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(AUX_STORE, 'readonly');
                    const store = tx.objectStore(AUX_STORE);
                    const request = store.get(preambleHash);
                    request.onerror = () => resolve(null);
                    request.onsuccess = () => {
                        const result = request.result;
                        if (result && result.version === AUX_CACHE_VERSION) {
                            auxMemoryCache.set(preambleHash, result);
                            resolve(result);
                        } else {
                            resolve(null);
                        }
                    };
                });
            } catch (e) {
                return null;
            }
        }

        // Save aux files for a preamble hash
        async function saveAuxCache(preambleHash, auxFiles) {
            const cacheEntry = {
                key: preambleHash,
                version: AUX_CACHE_VERSION,
                timestamp: Date.now(),
                files: auxFiles  // { 'document.aux': content, 'document.toc': content, ... }
            };
            auxMemoryCache.set(preambleHash, cacheEntry);
            try {
                const db = await openAuxCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(AUX_STORE, 'readwrite');
                    const store = tx.objectStore(AUX_STORE);
                    const request = store.put(cacheEntry);
                    request.onerror = () => resolve(false);
                    request.onsuccess = () => resolve(true);
                });
            } catch (e) {
                return false;
            }
        }

        // Restore cached aux files to FS before compilation
        function restoreAuxFiles(FS, auxCache) {
            if (!auxCache || !auxCache.files) return 0;
            let restored = 0;
            for (const [filename, content] of Object.entries(auxCache.files)) {
                try {
                    FS.writeFile('/' + filename, content);
                    restored++;
                } catch (e) {
                    // File may not be writable, ignore
                }
            }
            return restored;
        }

        // Save aux files from FS after successful compilation
        function collectAuxFiles(FS) {
            const auxExtensions = ['.aux', '.toc', '.lot', '.lof', '.bbl', '.blg', '.out', '.nav', '.snm'];
            const auxFiles = {};
            try {
                const files = FS.readdir('/');
                for (const file of files) {
                    const ext = file.substring(file.lastIndexOf('.'));
                    if (auxExtensions.includes(ext)) {
                        try {
                            const content = FS.readFile('/' + file, { encoding: 'utf8' });
                            auxFiles[file] = content;
                        } catch (e) {
                            // Couldn't read, skip
                        }
                    }
                }
            } catch (e) {
                // Ignore errors
            }
            return auxFiles;
        }

        // Extract preamble hash for aux caching (uses existing functions)
        function getPreambleHashForAux(source) {
            // Simple extraction before \begin{document}
            const match = source.match(/^([\s\S]*?)\\begin\{document\}/);
            const preamble = match ? match[1] : source.slice(0, 2000);
            // Normalize and hash
            const normalized = preamble.replace(/%.*$/gm, '').replace(/\s+/g, ' ').trim();
            let hash = 5381;
            for (let i = 0; i < normalized.length; i++) {
                hash = ((hash << 5) + hash) + normalized.charCodeAt(i);
                hash = hash & hash;
            }
            return 'aux_' + Math.abs(hash).toString(36);
        }

        // ============================================================
        // BREAKTHROUGH: Dynamic Format File Generation
        // ============================================================
        // Generate custom .fmt files from user's preamble.
        // Format files are TeX engine memory dumps AFTER loading packages.
        // Using a custom format = instant package loading on subsequent compiles.
        // Expected improvement: 50-70% faster compilation for complex preambles.

        const FMT_CACHE_VERSION = 1;
        const FMT_STORE = 'fmt-cache';
        let fmtCacheDb = null;

        // In-memory cache for format file metadata
        const fmtMemoryCache = new Map();

        async function openFmtCacheDb() {
            if (fmtCacheDb) return fmtCacheDb;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('siglum-fmt-cache', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    fmtCacheDb = request.result;
                    resolve(fmtCacheDb);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(FMT_STORE)) {
                        db.createObjectStore(FMT_STORE, { keyPath: 'key' });
                    }
                };
            });
        }

        // Get format file metadata for a preamble hash
        async function getFmtMeta(preambleHash) {
            if (fmtMemoryCache.has(preambleHash)) {
                return fmtMemoryCache.get(preambleHash);
            }
            try {
                const db = await openFmtCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(FMT_STORE, 'readonly');
                    const store = tx.objectStore(FMT_STORE);
                    const request = store.get(preambleHash);
                    request.onerror = () => resolve(null);
                    request.onsuccess = () => {
                        const result = request.result;
                        if (result && result.version === FMT_CACHE_VERSION) {
                            fmtMemoryCache.set(preambleHash, result);
                            resolve(result);
                        } else {
                            resolve(null);
                        }
                    };
                });
            } catch (e) {
                return null;
            }
        }

        // Save format file metadata to IDB
        async function saveFmtMeta(preambleHash, meta) {
            const cacheEntry = {
                key: preambleHash,
                version: FMT_CACHE_VERSION,
                timestamp: Date.now(),
                ...meta
            };
            fmtMemoryCache.set(preambleHash, cacheEntry);
            try {
                const db = await openFmtCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(FMT_STORE, 'readwrite');
                    const store = tx.objectStore(FMT_STORE);
                    const request = store.put(cacheEntry);
                    request.onerror = () => resolve(false);
                    request.onsuccess = () => resolve(true);
                });
            } catch (e) {
                return false;
            }
        }

        // Load custom format file from OPFS
        async function loadFmtFromOPFS(fmtPath) {
            return await readFromOPFS(fmtPath);
        }

        // Save custom format file to OPFS
        async function saveFmtToOPFS(fmtPath, fmtData) {
            return await writeToOPFS(fmtPath, fmtData);
        }

        // Generate a custom format file from preamble
        // This is THE breakthrough optimization - compile preamble once, reuse forever
        //
        // HOW IT WORKS:
        // 1. After first successful compile, we generate a format file that contains
        //    ALL packages pre-loaded (documentclass, usepackage commands processed)
        // 2. On subsequent compiles with same preamble, we skip package loading entirely
        //    by using this custom format file
        // 3. Expected speedup: 60-80% for complex documents (memoir: 8s -> 2s)
        //
        // IMPORTANT: Format generation runs AFTER successful compile when all
        // packages are already loaded in the FS (via lazy loading / CTAN fetch).
        // This is a background operation - doesn't block the user.

        let formatGenerationInProgress = new Set(); // Track preambles being generated

        async function generateCustomFormat(Module, FS, source, engine, preambleHash) {
            // Prevent duplicate generation
            if (formatGenerationInProgress.has(preambleHash)) {
                return null;
            }
            formatGenerationInProgress.add(preambleHash);

            log(` Generating custom format file (hash: ${preambleHash})...`);
            const formatStart = performance.now();

            // Extract preamble (everything before \begin{document})
            const preambleMatch = source.match(/^([\s\S]*?)\\begin\{document\}/);
            if (!preambleMatch) {
                formatGenerationInProgress.delete(preambleHash);
                log(` Cannot extract preamble from source`);
                return null;
            }

            // Clean preamble - remove comments and normalize whitespace
            let cleanPreamble = preambleMatch[1]
                .replace(/%.*$/gm, '')  // Remove comments
                .replace(/\\title\{[^}]*\}/g, '')  // Remove title (can vary)
                .replace(/\\author\{[^}]*\}/g, '') // Remove author (can vary)
                .replace(/\\date\{[^}]*\}/g, '');  // Remove date (can vary)

            // The format generation ini file
            // Uses \endlinechar trick to cleanly end input before \dump
            const fmtName = `siglum_${preambleHash}`;
            const iniContent = `% Custom format file for Siglum Engine
% Preamble hash: ${preambleHash}
% Generated: ${new Date().toISOString()}

${cleanPreamble}

% Set up for format dump
\\makeatletter
\\let\\@@end\\end
\\let\\end\\relax
\\catcode\`\\@=11
% Message shown when format is used
\\everyjob{\\typeout{[Siglum: Using cached format ${fmtName}]}}
\\catcode\`\\@=12
\\makeatother

% Dump the format
\\dump
`;

            try {
                // Write the ini file
                FS.writeFile(`/${fmtName}.ini`, iniContent);

                // Run pdftex -ini to generate the format
                // The format is built ON TOP of pdflatex format (loads it first)
                const result = Module.callMainWithRedirects([
                    'pdftex',
                    '-ini',
                    '-interaction=nonstopmode',
                    '-halt-on-error',
                    `&pdflatex`,  // Load pdflatex format as base
                    `/${fmtName}.ini`
                ], false);

                const formatTime = performance.now() - formatStart;

                if (result.exit_code !== 0) {
                    log(` Format generation failed: exit ${result.exit_code} (${formatTime.toFixed(0)}ms)`);
                    if (result.stdout) log(`stdout: ${result.stdout.slice(0, 500)}`);
                    if (result.stderr) log(`stderr: ${result.stderr.slice(0, 500)}`);
                    formatGenerationInProgress.delete(preambleHash);
                    return null;
                }

                // Check if .fmt file was created
                const fmtFilePath = `/${fmtName}.fmt`;
                if (!FS.analyzePath(fmtFilePath).exists) {
                    log(` Format file not created at ${fmtFilePath}`);
                    // List files to debug
                    try {
                        const files = FS.readdir('/').filter(f => f.endsWith('.fmt'));
                        log(`Available .fmt files: ${files.join(', ')}`);
                    } catch (e) {}
                    formatGenerationInProgress.delete(preambleHash);
                    return null;
                }

                // Read the format file
                const fmtData = FS.readFile(fmtFilePath);
                const fmtSizeMB = (fmtData.byteLength / 1024 / 1024).toFixed(1);
                log(` Format file generated: ${fmtSizeMB} MB in ${formatTime.toFixed(0)}ms`);

                // Save to OPFS (can be large, ~5-20MB for memoir)
                const opfsPath = `/fmt-cache/${fmtName}.fmt`;
                const saveStart = performance.now();
                await saveFmtToOPFS(opfsPath, fmtData);
                log(` Format saved to OPFS in ${(performance.now() - saveStart).toFixed(0)}ms`);

                // Save metadata to IDB
                await saveFmtMeta(preambleHash, {
                    fmtPath: opfsPath,
                    fmtName,
                    engine,
                    size: fmtData.byteLength,
                    generatedAt: Date.now(),
                    // Store preamble hash of packages for validation
                    packagesLoaded: Array.from(ctanMountedFiles).length
                });

                formatGenerationInProgress.delete(preambleHash);
                return {
                    fmtPath: opfsPath,
                    fmtName,
                    fmtData
                };
            } catch (e) {
                log(` Format generation error: ${e.message}`);
                formatGenerationInProgress.delete(preambleHash);
                return null;
            }
        }

        // Compile document using a cached custom format file
        // Returns { success, pdfData, exitCode } or null if format can't be used
        async function compileWithCustomFormat(Module, FS, source, fmtInfo, engine) {
            const { fmtName, fmtData } = fmtInfo;

            log(` Compiling with cached format: ${fmtName}`);
            const compileStart = performance.now();

            try {
                // Write the format file to FS
                const fmtPath = `/texlive/texmf-dist/texmf-var/web2c/pdftex/${fmtName}.fmt`;
                const fmtDir = fmtPath.substring(0, fmtPath.lastIndexOf('/'));
                ensureDirectory(FS, fmtDir);
                FS.writeFile(fmtPath, fmtData);

                // Write the FULL source document
                // The format contains preamble state, but TeX still needs to see
                // \begin{document} to know where content starts
                FS.writeFile('/document.tex', source);

                // Compile using our custom format
                const result = Module.callMainWithRedirects([
                    'pdflatex',
                    '--no-shell-escape',
                    '--interaction=nonstopmode',
                    '--halt-on-error',
                    '--fmt', fmtPath,
                    '/document.tex'
                ], false);

                const compileTime = performance.now() - compileStart;
                log(`pdfLaTeX (custom fmt): ${compileTime.toFixed(0)}ms (exit: ${result.exit_code})`);

                if (result.exit_code === 0) {
                    try {
                        const pdfData = FS.readFile('/document.pdf');
                        return { success: true, pdfData, exitCode: 0 };
                    } catch (e) {
                        return { success: false, pdfData: null, exitCode: result.exit_code };
                    }
                }

                return { success: false, pdfData: null, exitCode: result.exit_code };
            } catch (e) {
                log(` Custom format compile error: ${e.message}`);
                return null;
            }
        }

        // Check if we have a cached custom format for this preamble
        async function getCachedFormat(preambleHash, engine) {
            const meta = await getFmtMeta(preambleHash);
            if (!meta || meta.engine !== engine) return null;

            // Try to load from OPFS
            const fmtData = await loadFmtFromOPFS(meta.fmtPath);
            if (!fmtData) return null;

            return {
                fmtPath: meta.fmtPath,
                fmtName: meta.fmtName,
                fmtData
            };
        }

        // Get preamble hash specifically for format generation
        // (same as aux hash but with 'fmt_' prefix for clarity)
        function getPreambleHashForFmt(source) {
            const match = source.match(/^([\s\S]*?)\\begin\{document\}/);
            const preamble = match ? match[1] : source.slice(0, 2000);
            const normalized = preamble.replace(/%.*$/gm, '').replace(/\s+/g, ' ').trim();
            let hash = 5381;
            for (let i = 0; i < normalized.length; i++) {
                hash = ((hash << 5) + hash) + normalized.charCodeAt(i);
                hash = hash & hash;
            }
            return 'fmt_' + Math.abs(hash).toString(36);
        }

        // Extract just the preamble from source
        function extractPreambleContent(source) {
            const match = source.match(/^([\s\S]*?)\\begin\{document\}/);
            return match ? match[1] : source.slice(0, 2000);
        }

        // ============================================================
        // BREAKTHROUGH #1: Speculative Background Pre-compilation
        // ============================================================
        // While the user edits, we speculatively compile a preamble-only
        // document in the background. This pre-warms the TeX engine with
        // all packages loaded. When the user hits compile, we reuse the
        // pre-warmed WASM instance if the preamble hasn't changed.
        //
        // Expected improvement: 60-80% for complex documents (memoir: 8s -> 2s)
        // because package loading is the slowest part of compilation.

        const SpeculativeCompiler = {
            // State
            preWarmedModule: null,      // Pre-initialized WASM module
            preWarmedFS: null,          // Pre-initialized filesystem
            preWarmedPreambleHash: null, // Hash of preamble that was pre-compiled
            preWarmedEngine: null,       // Engine used for pre-warming
            preWarmedBundles: null,      // Bundles that were loaded
            isPreWarming: false,         // Currently running pre-warm compile
            pendingPreambleHash: null,   // Preamble hash waiting to be pre-warmed
            debounceTimer: null,         // Debounce timer for preamble changes

            // Configuration
            debounceMs: 1500,            // Wait this long after preamble change before pre-warming
            // DISABLED: Speculative pre-compilation conflicts with global state (mountedBundles, dirNodeCache)
            // and doesn't provide significant benefit since we can't reuse FS state across WASM instances.
            // The caches it would warm (CTAN OPFS, bundle memory) are already warm from the main compile.
            enabled: false,              // Master enable/disable

            // Hash just the preamble (normalized)
            hashPreamble(source) {
                const match = source.match(/^([\s\S]*?)\\begin\{document\}/);
                const preamble = match ? match[1] : source.slice(0, 2000);
                // Normalize: remove comments, collapse whitespace
                const normalized = preamble
                    .replace(/%.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                let hash = 5381;
                for (let i = 0; i < normalized.length; i++) {
                    hash = ((hash << 5) + hash) + normalized.charCodeAt(i);
                    hash = hash & hash;
                }
                return 'pre_' + Math.abs(hash).toString(36);
            },

            // Called when source changes - debounces and triggers pre-warm
            onSourceChange(source) {
                if (!this.enabled) return;

                const newHash = this.hashPreamble(source);

                // If preamble hasn't changed, nothing to do
                if (newHash === this.preWarmedPreambleHash) return;

                // If we're already pre-warming for this hash, skip
                if (newHash === this.pendingPreambleHash && this.isPreWarming) return;

                // Clear any pending pre-warm
                clearTimeout(this.debounceTimer);
                this.pendingPreambleHash = newHash;

                // Debounce - wait for user to stop typing in preamble
                this.debounceTimer = setTimeout(() => {
                    this.startPreWarm(source, newHash);
                }, this.debounceMs);
            },

            // Start pre-warming in background
            async startPreWarm(source, preambleHash) {
                if (this.isPreWarming) {
                    console.log('[SpeculativeCompiler] Already pre-warming, skipping');
                    return;
                }

                // Don't interfere with active compilation
                const btn = document.getElementById('compileBtn');
                if (btn && btn.disabled) {
                    console.log('[SpeculativeCompiler] Compile in progress, skipping pre-warm');
                    return;
                }

                this.isPreWarming = true;
                const startTime = performance.now();

                try {
                    console.log(`[SpeculativeCompiler] Starting pre-warm for preamble ${preambleHash}...`);

                    // Detect engine
                    const { engine } = getEngineWithReason(source);

                    // Get bundles needed for this document
                    await Promise.all([loadManifest(), loadBundleDeps()]);

                    // Ensure manifest is loaded
                    if (!fileManifest || Object.keys(fileManifest).length === 0) {
                        console.log('[SpeculativeCompiler] Manifest not loaded, aborting pre-warm');
                        this.isPreWarming = false;
                        return;
                    }

                    const { bundles: bundlesToLoad, missingPackages } = checkPackages(source, engine);

                    // Load all bundles into bundleCache
                    await Promise.all(bundlesToLoad.map(b => loadBundle(b)));

                    // Create a fresh WASM module for pre-warming
                    // Note: This is separate from the main compile's WASM instance
                    const Module = await initBusyTeX(true);
                    const FS = Module.FS;

                    // Clear tracking for this fresh FS (pre-warm uses its own isolated state)
                    const localMountedBundles = new Set();
                    dirNodeCache.clear();

                    // Mount bundles (lazy)
                    const enableLazyFS = document.getElementById('enableLazyFS').checked;
                    let totalMounted = 0;
                    if (enableLazyFS) {
                        for (const bundleName of bundlesToLoad) {
                            totalMounted += mountBundleLazy(FS, bundleName);
                            localMountedBundles.add(bundleName);
                        }
                    } else {
                        for (const bundleName of bundlesToLoad) {
                            if (localMountedBundles.has(bundleName)) continue;
                            const bundleData = bundleCache.get(bundleName);
                            if (!bundleData) {
                                console.log(`[SpeculativeCompiler] Bundle ${bundleName} not in cache, skipping`);
                                continue;
                            }
                            const dataView = new Uint8Array(bundleData);
                            for (const [path, info] of Object.entries(fileManifest)) {
                                if (info.bundle === bundleName) {
                                    const dirPath = path.substring(0, path.lastIndexOf('/'));
                                    ensureDirectory(FS, dirPath);
                                    try {
                                        FS.writeFile(path, dataView.slice(info.start, info.end));
                                        totalMounted++;
                                    } catch (e) {}
                                }
                            }
                            localMountedBundles.add(bundleName);
                        }
                    }

                    // Fetch missing packages from CTAN if enabled
                    const enableCtan = document.getElementById('enableCtan').checked;
                    if (enableCtan && missingPackages.length > 0) {
                        const ctanFetchedSet = new Set();
                        for (const pkg of missingPackages) {
                            await downloadAndMountCTANPackage(pkg, FS, ctanFetchedSet);
                        }
                    }

                    // Generate ls-R (ensure directory exists)
                    const lsRContent = generateLsR(FS, '/texlive/texmf-dist');
                    ensureDirectory(FS, '/texlive/texmf-dist');
                    FS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);

                    // Create preamble-only test document
                    // This runs TeX through all package loading but stops immediately
                    const preambleMatch = source.match(/^([\s\S]*?)\\begin\{document\}/);
                    const preamble = preambleMatch ? preambleMatch[1] : source.slice(0, 2000);
                    const testDoc = preamble + `
\\begin{document}
% Speculative pre-warm - minimal document body
\\end{document}
`;
                    FS.writeFile('/document.tex', testDoc);

                    // Run the pre-warm compile
                    console.log(`[SpeculativeCompiler] Running pre-warm compile (${engine})...`);
                    const compileStart = performance.now();

                    if (engine === 'pdflatex') {
                        // Apply pdflatex workarounds
                        let sourceToWrite = testDoc;
                        sourceToWrite = injectMicrotypeWorkaround(sourceToWrite);
                        const baseMaps = [
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cm.map',
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cmextra.map',
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/symbols.map',
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/euler.map',
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/latxfont.map',
                        ];
                        const existingMaps = baseMaps.filter(m => FS.analyzePath(m).exists);
                        if (existingMaps.length > 0) {
                            sourceToWrite = injectPdfMapFileCommands(sourceToWrite, existingMaps);
                        }
                        FS.writeFile('/document.tex', sourceToWrite);

                        Module.callMainWithRedirects([
                            'pdflatex',
                            '--no-shell-escape',
                            '--interaction=nonstopmode',
                            '--halt-on-error',
                            '--fmt', '/texlive/texmf-dist/texmf-var/web2c/pdftex/pdflatex.fmt',
                            '/document.tex'
                        ]);
                    } else {
                        Module.callMainWithRedirects([
                            'xelatex',
                            '--no-shell-escape',
                            '--interaction=nonstopmode',
                            '--halt-on-error',
                            '--no-pdf',
                            '--fmt', '/texlive/texmf-dist/texmf-var/web2c/xetex/xelatex.fmt',
                            '/document.tex'
                        ]);
                    }

                    const compileTime = performance.now() - compileStart;
                    const totalTime = performance.now() - startTime;

                    // Track which files were actually accessed during pre-warm
                    // These are the files TeX needs - we'll eagerly load them on real compile
                    const accessedFiles = new Set();
                    for (const path of Object.keys(fileManifest)) {
                        try {
                            // Check if file was loaded (lazy stub replaced with real content)
                            const stat = FS.stat(path);
                            if (stat.size > 0) {
                                accessedFiles.add(path);
                            }
                        } catch (e) {}
                    }

                    // Save the pre-warmed state
                    // NOTE: We CANNOT reuse the WASM instance because TeX engine state
                    // is corrupted after a compile. But we CAN track which files were needed!
                    this.preWarmedFS = FS;
                    this.preWarmedModule = Module;
                    this.preWarmedPreambleHash = preambleHash;
                    this.preWarmedEngine = engine;
                    this.preWarmedBundles = bundlesToLoad;
                    this.preWarmedFiles = accessedFiles;  // NEW: Track accessed files

                    console.log(`[SpeculativeCompiler] Pre-warm complete in ${totalTime.toFixed(0)}ms (compile: ${compileTime.toFixed(0)}ms)`);
                    console.log(`[SpeculativeCompiler] Ready with ${totalMounted} files mounted, ${bundlesToLoad.length} bundles, ${accessedFiles.size} files accessed`);

                } catch (e) {
                    console.error('[SpeculativeCompiler] Pre-warm failed:', e);
                    console.error('[SpeculativeCompiler] Stack:', e.stack || '<generic error, no stack>');
                    console.error('[SpeculativeCompiler] Error message:', e.message);
                    if (e.node) console.error('[SpeculativeCompiler] FS node:', e.node);
                    this.invalidate();
                } finally {
                    this.isPreWarming = false;
                }
            },

            // Check if we have a valid pre-warmed state for the given source
            hasValidPreWarm(source, engine) {
                if (!this.preWarmedPreambleHash) return false;
                if (this.preWarmedEngine !== engine) return false;
                const currentHash = this.hashPreamble(source);
                return currentHash === this.preWarmedPreambleHash;
            },

            // Get the pre-warmed FS state (bundles + CTAN files + accessed files list)
            // The caller will create a fresh WASM module but can eagerly load accessed files
            getPreWarmedState() {
                if (!this.preWarmedFS) return null;
                return {
                    fs: this.preWarmedFS,
                    bundles: this.preWarmedBundles,
                    preambleHash: this.preWarmedPreambleHash,
                    engine: this.preWarmedEngine,
                    accessedFiles: this.preWarmedFiles || new Set()
                };
            },

            // Invalidate the pre-warmed state
            invalidate() {
                this.preWarmedModule = null;
                this.preWarmedFS = null;
                this.preWarmedPreambleHash = null;
                this.preWarmedEngine = null;
                this.preWarmedBundles = null;
                this.preWarmedFiles = null;
            }
        };

        // ============================================================
        // BREAKTHROUGH #1.5: WASM Memory Snapshotting
        // ============================================================
        // After running preamble (loading all packages), capture the entire
        // WASM heap memory. On subsequent compiles with the same preamble,
        // restore the snapshot instead of re-parsing all packages.
        //
        // This is the "holy grail" optimization because:
        // - Package loading (parsing .sty files) is ~40% of compile time
        // - TeX's internal state after preamble is deterministic for same preamble
        // - Restoring memory is O(size) copy vs O(complexity) parsing
        //
        // Challenges:
        // - WASM memory can be large (16-64MB for complex documents)
        // - Need to also snapshot the Emscripten FS state
        // - TeX globals may contain absolute pointers that break on restore
        //
        // References:
        // - https://emscripten.org/docs/tools_reference/settings_reference.html
        // - https://github.com/emscripten-core/emscripten/issues/19832

        // ============================================================
        // Custom Format File Generation (via Web Worker)
        // ============================================================
        // Generate format files with packages pre-loaded (e.g., memoir.fmt)
        // This is done in a Web Worker to avoid the tounicode.c assertion error
        // that occurs when generating formats after compilation.
        //
        // A format file includes:
        // - LaTeX base macros
        // - The document class (memoir, article, etc.)
        // - Any \usepackage commands
        //
        // Using a custom format can skip 4-6 seconds of package loading.
        // ============================================================

        const FormatGenerator = {
            // Cache of generated formats: preambleHash -> Uint8Array
            formats: new Map(),
            generating: new Map(),  // Track in-progress generations
            usedFormats: new Set(), // Track formats that have been used at least once (aux files are compatible)
            enabled: true,

            // Generate a format file for the given preamble
            // Returns the format file data or null if generation fails
            async generate(preambleContent, engine = 'pdflatex') {
                if (!this.enabled) return null;

                const preambleHash = this.hashPreamble(preambleContent);
                const cacheKey = `${preambleHash}_${engine}`;

                // Check if already cached
                if (this.formats.has(cacheKey)) {
                    console.log(`[FormatGenerator] Using cached format: ${cacheKey}`);
                    return this.formats.get(cacheKey);
                }

                // Check if already generating
                if (this.generating.has(cacheKey)) {
                    console.log(`[FormatGenerator] Waiting for in-progress generation: ${cacheKey}`);
                    return this.generating.get(cacheKey);
                }

                console.log(`[FormatGenerator] Generating format for: ${cacheKey}`);
                const generatePromise = this._doGenerate(preambleContent, engine, cacheKey);
                this.generating.set(cacheKey, generatePromise);

                try {
                    const result = await generatePromise;
                    if (result) {
                        this.formats.set(cacheKey, result);
                    }
                    return result;
                } finally {
                    this.generating.delete(cacheKey);
                }
            },

            async _doGenerate(preambleContent, engine, cacheKey) {
                const startTime = performance.now();

                try {
                    // Create a fresh WASM module (never used for compilation)
                    const Module = await initBusyTeX(true);
                    const FS = Module.FS;

                    // Reset global state for fresh module
                    const savedMounted = new Set(mountedBundles);
                    const savedDirCache = new Map(dirNodeCache);
                    mountedBundles.clear();
                    dirNodeCache.clear();

                    // Mount all bundles needed for the preamble
                    const { bundles: bundlesToLoad } = checkPackages(
                        preambleContent + '\\begin{document}\\end{document}',
                        engine
                    );

                    // Load and mount bundles
                    await Promise.all(bundlesToLoad.map(b => loadBundle(b)));
                    for (const bundleName of bundlesToLoad) {
                        mountBundleLazy(FS, bundleName);
                    }

                    // Re-mount CTAN files from cache (memoir, etc.)
                    // These were fetched during previous compiles and stored in OPFS
                    console.log(`[FormatGenerator] ctanMountedFiles has ${ctanMountedFiles.size} entries`);
                    let ctanRemounted = 0;
                    let ctanFailed = 0;
                    for (const filePath of ctanMountedFiles) {
                        // Skip files already in bundles
                        if (fileManifest[filePath]) {
                            console.log(`[FormatGenerator] Skipping ${filePath} (in bundle)`);
                            continue;
                        }
                        const content = await readFromOPFS(filePath);
                        if (content) {
                            const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                            ensureDirectory(FS, dirPath);
                            try {
                                FS.writeFile(filePath, content);
                                ctanRemounted++;
                            } catch (e) {
                                console.error(`[FormatGenerator] Failed to write ${filePath}:`, e);
                                ctanFailed++;
                            }
                        } else {
                            console.log(`[FormatGenerator] No OPFS content for ${filePath}`);
                            ctanFailed++;
                        }
                    }
                    console.log(`[FormatGenerator] Re-mounted ${ctanRemounted} CTAN files (${ctanFailed} failed)`);

                    // Pre-fetch cm-super if T1 fontenc is detected in preamble
                    // T1 encoding requires cm-super Type1 fonts for proper PDF output
                    // Common patterns: \usepackage[T1]{fontenc}, \usepackage{fontenc} (defaults may use T1)
                    const usesT1Fontenc = /\\usepackage\s*\[[^\]]*T1[^\]]*\]\s*\{fontenc\}/.test(preambleContent) ||
                                          /\\usepackage\s*\{fontenc\}/.test(preambleContent);
                    if (usesT1Fontenc) {
                        console.log('[FormatGenerator] T1 fontenc detected - pre-fetching cm-super fonts');
                        try {
                            const fetched = await downloadAndMountCTANPackage('cm-super', FS, new Set());
                            if (fetched) {
                                console.log('[FormatGenerator] cm-super pre-fetched successfully');
                            } else {
                                console.log('[FormatGenerator] cm-super pre-fetch returned false (may already be cached)');
                            }
                        } catch (e) {
                            console.warn('[FormatGenerator] cm-super pre-fetch failed:', e);
                        }
                    }

                    // Generate ls-R
                    const lsRContent = generateLsR(FS, '/texlive/texmf-dist');
                    FS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);

                    // Apply microtype workaround to the preamble before creating format
                    // This disables font expansion which requires cm-super fonts we don't have
                    let modifiedPreamble = preambleContent;
                    if (modifiedPreamble.includes('microtype')) {
                        const docclassMatch = modifiedPreamble.match(/\\documentclass/);
                        if (docclassMatch) {
                            const insertPos = docclassMatch.index;
                            const workaround = `% Siglum: Disable microtype font expansion (requires cm-super fonts)\n\\PassOptionsToPackage{expansion=false}{microtype}\n`;
                            modifiedPreamble = modifiedPreamble.slice(0, insertPos) + workaround + modifiedPreamble.slice(insertPos);
                            console.log('[FormatGenerator] Applied microtype expansion=false workaround');
                        }
                    }

                    // Create the .ini file that loads the preamble and dumps the format
                    // Format: load base format, then packages, then \dump
                    const iniContent = `${modifiedPreamble}
\\dump
`;
                    FS.writeFile('/myformat.ini', iniContent);

                    // Run pdfTeX in IniTeX mode
                    // Use --fmt with full path since kpathsea can't find it via name
                    // Note: Don't include .fmt extension - TeX adds it automatically
                    const result = Module.callMainWithRedirects([
                        'pdflatex',
                        '-ini',
                        '-jobname=myformat',
                        '-interaction=nonstopmode',
                        '&/texlive/texmf-dist/texmf-var/web2c/pdftex/pdflatex',
                        '/myformat.ini'
                    ]);

                    // Restore global state
                    mountedBundles.clear();
                    savedMounted.forEach(b => mountedBundles.add(b));
                    dirNodeCache.clear();
                    savedDirCache.forEach((v, k) => dirNodeCache.set(k, v));

                    if (result.exit_code !== 0) {
                        console.error('[FormatGenerator] Generation failed:', result.exit_code);
                        try {
                            const log = new TextDecoder().decode(FS.readFile('/myformat.log'));
                            console.error('[FormatGenerator] Log:', log.slice(-2000));
                        } catch (e) {}
                        return null;
                    }

                    // Read the generated format file
                    try {
                        const formatData = FS.readFile('/myformat.fmt');
                        const genTime = performance.now() - startTime;
                        console.log(`[FormatGenerator] Generated ${(formatData.byteLength / 1024 / 1024).toFixed(1)}MB format in ${genTime.toFixed(0)}ms`);
                        return new Uint8Array(formatData);
                    } catch (e) {
                        console.error('[FormatGenerator] Failed to read format file:', e);
                        return null;
                    }

                } catch (e) {
                    console.error('[FormatGenerator] Error:', e);
                    return null;
                }
            },

            // Extract packages from preamble for dependency resolution
            parsePreamblePackages(preamble) {
                const packages = [];
                const pkgRegex = /\\usepackage(?:\[[^\]]*\])?\{([^}]+)\}/g;
                let match;
                while ((match = pkgRegex.exec(preamble)) !== null) {
                    const pkgList = match[1].split(',').map(p => p.trim());
                    packages.push(...pkgList);
                }
                return packages;
            },

            hashPreamble(preamble) {
                let hash = 5381;
                for (let i = 0; i < preamble.length; i++) {
                    hash = ((hash << 5) + hash) + preamble.charCodeAt(i);
                    hash = hash & hash;
                }
                return 'fmt_' + Math.abs(hash).toString(36);
            },

            // Check if we have a format for this preamble
            has(preambleContent, engine = 'pdflatex') {
                const preambleHash = this.hashPreamble(preambleContent);
                const cacheKey = `${preambleHash}_${engine}`;
                return this.formats.has(cacheKey);
            },

            // Clear all cached formats
            clear() {
                this.formats.clear();
                this.usedFormats.clear();
                console.log('[FormatGenerator] Cleared all formats');
            }
        };

        // ============================================================
        // Document Hash Caching
        // ============================================================
        // Cache compiled PDFs by document hash.
        // If the exact same document is compiled again, return cached PDF instantly.
        // Expected improvement: 100% time savings for unchanged documents.

        const DOC_CACHE_VERSION = 1;
        const DOC_STORE = 'doc-cache';
        let docCacheDb = null;

        // In-memory cache for document PDFs (very fast, limited by browser memory)
        const docMemoryCache = new Map();
        const MAX_DOC_CACHE_SIZE = 10;  // Keep last 10 compiled documents in memory

        async function openDocCacheDb() {
            if (docCacheDb) return docCacheDb;
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('siglum-doc-cache', 1);
                request.onerror = () => reject(request.error);
                request.onsuccess = () => {
                    docCacheDb = request.result;
                    resolve(docCacheDb);
                };
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(DOC_STORE)) {
                        db.createObjectStore(DOC_STORE, { keyPath: 'key' });
                    }
                };
            });
        }

        // Hash the entire document source
        function hashDocument(source) {
            let hash = 5381;
            for (let i = 0; i < source.length; i++) {
                hash = ((hash << 5) + hash) + source.charCodeAt(i);
                hash = hash & hash;
            }
            return 'doc_' + Math.abs(hash).toString(36);
        }

        // Get cached PDF for document hash
        // Returns a COPY of the cached data to avoid detached buffer issues with PDF.js
        async function getCachedPdf(docHash, engine) {
            const cacheKey = `${docHash}_${engine}`;

            // Check memory cache first (instant)
            if (docMemoryCache.has(cacheKey)) {
                const cached = docMemoryCache.get(cacheKey);
                if (cached.version === DOC_CACHE_VERSION && cached.pdfData) {
                    // Check if buffer is still valid (not detached)
                    try {
                        // Return a copy to avoid detached buffer issues when PDF.js transfers it
                        return new Uint8Array(cached.pdfData);
                    } catch (e) {
                        // Buffer was detached - remove from memory cache and fall through to IndexedDB
                        console.warn('[DocCache] Memory cache buffer detached, falling back to IndexedDB');
                        docMemoryCache.delete(cacheKey);
                    }
                }
            }

            // Check IndexedDB
            try {
                const db = await openDocCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(DOC_STORE, 'readonly');
                    const store = tx.objectStore(DOC_STORE);
                    const request = store.get(cacheKey);
                    request.onerror = () => resolve(null);
                    request.onsuccess = () => {
                        const result = request.result;
                        if (result && result.version === DOC_CACHE_VERSION && result.pdfData) {
                            // Add to memory cache for faster subsequent access
                            docMemoryCache.set(cacheKey, result);
                            // Return a copy to avoid detached buffer issues
                            resolve(new Uint8Array(result.pdfData));
                        } else {
                            resolve(null);
                        }
                    };
                });
            } catch (e) {
                return null;
            }
        }

        // Save compiled PDF to cache
        async function saveCachedPdf(docHash, engine, pdfData) {
            const cacheKey = `${docHash}_${engine}`;
            // Store a COPY of the pdfData to avoid issues if the original buffer gets detached
            // (e.g., PDF.js transfers buffers when rendering)
            const pdfDataCopy = new Uint8Array(pdfData);
            const cacheEntry = {
                key: cacheKey,
                version: DOC_CACHE_VERSION,
                timestamp: Date.now(),
                pdfData: pdfDataCopy
            };

            // Add to memory cache (with LRU eviction)
            if (docMemoryCache.size >= MAX_DOC_CACHE_SIZE) {
                // Remove oldest entry
                const oldestKey = docMemoryCache.keys().next().value;
                docMemoryCache.delete(oldestKey);
            }
            docMemoryCache.set(cacheKey, cacheEntry);

            // Save to IndexedDB
            try {
                const db = await openDocCacheDb();
                return new Promise((resolve) => {
                    const tx = db.transaction(DOC_STORE, 'readwrite');
                    const store = tx.objectStore(DOC_STORE);
                    const request = store.put(cacheEntry);
                    request.onerror = () => resolve(false);
                    request.onsuccess = () => resolve(true);
                });
            } catch (e) {
                return false;
            }
        }

        // Load package from cache: meta from IDB, files from OPFS
        async function loadPackageFromCache(packageName, FS) {
            let meta = await getPackageMeta(packageName);

            // Check if this is an alias - if so, load the real package
            if (meta && meta.aliasFor) {
                if (meta.cacheVersion !== CTAN_CACHE_VERSION) {
                    return null;  // Alias entry is outdated
                }
                log(`  ${packageName} is alias for ${meta.aliasFor}`);
                // Check if the aliased package exists in bundles (not just cache)
                // If so, count as cache hit since we know about this alias
                const aliasedPkgPath = packageExistsInFS(FS, meta.aliasFor);
                if (aliasedPkgPath) {
                    log(`    ${meta.aliasFor} found in bundles at ${aliasedPkgPath}`);
                    cacheHitCount++;
                    updateStats();
                    return { mounted: 1, dependencies: [] };
                }
                return loadPackageFromCache(meta.aliasFor, FS);
            }

            // Check if this package is cached as "not found"
            if (meta && meta.notFound) {
                if (meta.cacheVersion !== CTAN_CACHE_VERSION) {
                    return null;  // Entry is outdated
                }
                log(`  ${packageName} cached as not found on CTAN`);
                cacheHitCount++;
                updateStats();
                return { mounted: 1, dependencies: [] };  // Return success to avoid re-fetching
            }

            if (!meta || !meta.files) {
                // Not in cache
                return null;
            }

            // Check cache version - invalidate old caches
            if (meta.cacheVersion !== CTAN_CACHE_VERSION) {
                log(`  Cache version mismatch for ${packageName} (v${meta.cacheVersion || 1} != v${CTAN_CACHE_VERSION}), will re-fetch`);
                return null;
            }

            log(`  Loading ${packageName} from browser cache (${meta.files.length} files)...`);
            let mounted = 0;
            let skipped = 0;
            let opfsFailed = 0;
            for (const filePath of meta.files) {
                // CRITICAL: Don't overwrite files from bundles!
                // Check fileManifest first (lazy stubs aren't detected by analyzePath)
                if (fileManifest[filePath]) {
                    skipped++;
                    continue;  // Skip - bundle version takes precedence
                }
                try {
                    if (FS.analyzePath(filePath).exists) {
                        skipped++;
                        continue;  // Skip - already mounted
                    }
                } catch (e) {}

                const content = await readFromOPFS(filePath);
                if (content) {
                    const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                    ensureDirectory(FS, dirPath);
                    try {
                        FS.writeFile(filePath, content);
                        ctanMountedFiles.add(filePath);  // Track for re-mounting on WASM reinit
                        mounted++;
                    } catch (e) {}
                } else {
                    opfsFailed++;
                }
            }
            // Count as cache hit if we found the package (even if all files were skipped)
            // Files might be skipped because they exist in bundles - that's still a successful cache lookup
            const wasInCache = mounted > 0 || skipped > 0;
            if (wasInCache) {
                cacheHitCount++;
                updateStats();
            }
            let cacheMsg = `    Restored ${mounted}/${meta.files.length} files from cache`;
            if (skipped > 0) cacheMsg += ` (${skipped} skipped)`;
            if (opfsFailed > 0) cacheMsg += ` (${opfsFailed} OPFS read failures)`;
            log(cacheMsg);

            // If this is a font package, append map files to pdftex.map
            const mapFilePaths = meta.files.filter(f => f.endsWith('.map') && !f.includes('pdftex.map'));
            if (mapFilePaths.length > 0) {
                await appendCachedMapsToUpdmap(FS, mapFilePaths);
            }

            // Copy .enc files from type1/ to enc/ where kpathsea expects them
            const filesObj = {};
            for (const f of meta.files) filesObj[f] = true;
            copyEncFilesToStandardLocation(FS, filesObj);

            // Return success if package was in cache (mounted OR skipped counts as success)
            // This prevents re-fetching from CTAN when all files were skipped due to bundles
            return { mounted: mounted + skipped, dependencies: meta.dependencies || [] };
        }

        // Rewrite map file entries to use absolute paths
        // This bypasses kpathsea file search which doesn't work reliably in WASM
        // Map file format: fontname PSname encoding <encfile <pfbfile
        // We replace <filename with </absolute/path/to/filename
        function rewriteMapWithAbsolutePaths(mapContent, FS, mapFilePath) {
            const lines = mapContent.split('\n');
            const rewrittenLines = [];

            // Get the directory containing the map file to search nearby
            const mapDir = mapFilePath.substring(0, mapFilePath.lastIndexOf('/'));
            // For cm-super, fonts are in type1/public/cm-super, enc files in enc/dvips/cm-super
            const packageName = mapFilePath.includes('/cm-super') ? 'cm-super' :
                               mapFilePath.match(/\/([^\/]+)\/[^\/]+\.map$/)?.[1] || '';

            const searchPaths = {
                pfb: [
                    `/texlive/texmf-dist/fonts/type1/public/${packageName}`,
                    '/texlive/texmf-dist/fonts/type1/public/cm-super',
                    mapDir
                ],
                enc: [
                    `/texlive/texmf-dist/fonts/enc/dvips/${packageName}`,
                    '/texlive/texmf-dist/fonts/enc/dvips/cm-super',
                    `/texlive/texmf-dist/fonts/type1/public/${packageName}`,
                    '/texlive/texmf-dist/fonts/type1/public/cm-super',
                    mapDir
                ]
            };

            for (const line of lines) {
                // Skip comments and empty lines
                if (line.trim().startsWith('%') || line.trim() === '') {
                    rewrittenLines.push(line);
                    continue;
                }

                let rewrittenLine = line;

                // Find all file references like <filename.pfb or <filename.enc
                // Pattern: < followed by optional < (for embedding), then filename
                const fileRefs = line.matchAll(/<<?([a-zA-Z0-9_-]+\.(pfb|enc))/g);

                for (const match of fileRefs) {
                    const fullMatch = match[0];  // e.g., "<sfrm1000.pfb" or "<<sfrm1000.pfb"
                    const filename = match[1];   // e.g., "sfrm1000.pfb"
                    const ext = match[2];        // e.g., "pfb" or "enc"
                    const prefix = fullMatch.startsWith('<<') ? '<<' : '<';

                    // Search for the file in known paths
                    const paths = searchPaths[ext] || [];
                    let absolutePath = null;

                    for (const searchDir of paths) {
                        const candidatePath = `${searchDir}/${filename}`;
                        try {
                            if (FS.analyzePath(candidatePath).exists) {
                                absolutePath = candidatePath;
                                break;
                            }
                        } catch (e) {}
                    }

                    if (absolutePath) {
                        // Replace bare filename with absolute path
                        rewrittenLine = rewrittenLine.replace(fullMatch, `${prefix}${absolutePath}`);
                    }
                }

                rewrittenLines.push(rewrittenLine);
            }

            return rewrittenLines.join('\n');
        }

        // Inject \pdfmapfile commands into LaTeX source for pdfLaTeX
        // This loads font maps at document processing time, bypassing the startup pdftex.map
        // which doesn't work reliably with dynamically mounted fonts in WASM
        function injectPdfMapFileCommands(source, mapFilePaths) {
            if (mapFilePaths.length === 0) return source;

            // Build \pdfmapfile commands - use + prefix to add to existing maps
            const mapCommands = mapFilePaths.map(p => `\\pdfmapfile{+${p}}`).join('\n');

            // Find the position after \documentclass{...} but before \begin{document}
            // We need to insert after \documentclass but ideally in the preamble
            const documentclassMatch = source.match(/\\documentclass(\[[^\]]*\])?\{[^}]+\}/);
            if (!documentclassMatch) {
                log('Warning: Could not find \\documentclass to inject \\pdfmapfile');
                return source;
            }

            const insertPos = documentclassMatch.index + documentclassMatch[0].length;
            const preambleInsert = `\n% Font maps injected by Siglum for cm-super support\n${mapCommands}\n`;

            log(`Injecting ${mapFilePaths.length} \\pdfmapfile commands into document preamble`);
            for (const p of mapFilePaths) {
                log(`  \\pdfmapfile{+${p}}`);
            }

            return source.slice(0, insertPos) + preambleInsert + source.slice(insertPos);
        }

        // Inject microtype workaround for pdfLaTeX - disable font expansion since we don't have cm-super
        // This must be called BEFORE \documentclass because \PassOptionsToPackage only works before loading
        function injectMicrotypeWorkaround(source) {
            // Check if the document uses microtype
            if (!source.includes('microtype')) {
                return source;
            }

            // Insert \PassOptionsToPackage before \documentclass
            const documentclassMatch = source.match(/\\documentclass/);
            if (!documentclassMatch) {
                return source;
            }

            const insertPos = documentclassMatch.index;
            const workaround = `% Siglum: Disable microtype font expansion (requires cm-super fonts not available)
\\PassOptionsToPackage{expansion=false}{microtype}
`;

            log('Injecting microtype expansion=false workaround');
            return source.slice(0, insertPos) + workaround + source.slice(insertPos);
        }

        // Append cached font map files (already in FS) to pdftex.map
        async function appendCachedMapsToUpdmap(FS, mapFilePaths) {
            const PDFTEX_MAP_PATH = '/texlive/texmf-dist/texmf-var/fonts/map/pdftex/updmap/pdftex.map';

            // Track these map files for re-appending after WASM reinit
            for (const p of mapFilePaths) {
                ctanFontMapFiles.add(p);
            }

            try {
                let existingMap = '';
                try {
                    existingMap = new TextDecoder().decode(FS.readFile(PDFTEX_MAP_PATH));
                } catch (e) {
                    log('    Warning: pdftex.map not found');
                    return;
                }

                let appendedContent = '';
                for (const mapPath of mapFilePaths) {
                    try {
                        const content = new TextDecoder().decode(FS.readFile(mapPath));
                        const mapName = mapPath.split('/').pop();
                        // Check if already appended (with absolute paths marker)
                        if (!existingMap.includes(`Appended from ${mapName}`)) {
                            // Rewrite file references to use absolute paths
                            // This bypasses kpathsea which doesn't work reliably in WASM
                            const rewrittenContent = rewriteMapWithAbsolutePaths(content, FS, mapPath);
                            appendedContent += `\n% === Appended from ${mapName} (with absolute paths) ===\n`;
                            appendedContent += rewrittenContent;
                            log(`    Appended font map: ${mapName} (with absolute paths)`);

                            // Debug: show sample of rewritten entries for tcrm1000
                            const tcrm = rewrittenContent.split('\n').find(l => l.startsWith('tcrm1000'));
                            if (tcrm) {
                                log(`    DEBUG full tcrm1000 entry: ${tcrm}`);
                            }
                        }
                    } catch (e) {}
                }

                if (appendedContent) {
                    FS.writeFile(PDFTEX_MAP_PATH, existingMap + appendedContent);
                    // Debug: verify the tcrm1000 entry in the final pdftex.map
                    try {
                        const finalMap = new TextDecoder().decode(FS.readFile(PDFTEX_MAP_PATH));
                        const finalTcrm = finalMap.split('\n').find(l => l.startsWith('tcrm1000'));
                        if (finalTcrm) {
                            log(`    DEBUG tcrm1000 in final pdftex.map: ${finalTcrm}`);
                        }
                    } catch(e) {}
                }
            } catch (e) {}
        }

        // Save package to cache: meta to IDB, files to OPFS
        async function savePackageToCache(packageName, filesMap, dependencies) {
            const filePaths = Object.keys(filesMap);

            // Save file contents to OPFS
            let saved = 0;
            for (const [filePath, fileInfo] of Object.entries(filesMap)) {
                let content;
                if (fileInfo.encoding === 'base64') {
                    // Decode base64 to binary before saving
                    const binaryString = atob(fileInfo.content);
                    const bytes = new Uint8Array(binaryString.length);
                    for (let i = 0; i < binaryString.length; i++) {
                        bytes[i] = binaryString.charCodeAt(i);
                    }
                    content = bytes;
                } else if (typeof fileInfo.content === 'string') {
                    content = new TextEncoder().encode(fileInfo.content);
                } else {
                    content = fileInfo.content;
                }
                if (await writeToOPFS(filePath, content)) {
                    saved++;
                }
            }

            // Save metadata to IndexedDB
            await savePackageMeta(packageName, {
                files: filePaths,
                dependencies: dependencies || [],
                fileCount: filePaths.length,
                cacheVersion: CTAN_CACHE_VERSION
            });

            log(`    Cached ${saved} files to browser storage`);
            return saved > 0;
        }

        // Stats
        let filesFetched = 0;
        let bytesDownloaded = 0;
        let requestCount = 0;
        let ctanFetchCount = 0;
        let cacheHitCount = 0;

        // ============================================================
        // Engine Selector - Adaptive LaTeX engine selection
        // ============================================================
        const EngineSelector = (function() {
            const STORAGE_PREFIX = 'latex_engine_';

            // Packages that REQUIRE specific engines
            const REQUIREMENTS = {
                xelatex: {
                    packages: new Set([
                        'fontspec', 'unicode-math', 'polyglossia', 'xeCJK', 'xunicode',
                        'xltxtra', 'mathspec', 'realscripts', 'metalogo', 'xetex'
                    ]),
                    commands: [
                        /\\setmainfont\b/,
                        /\\setsansfont\b/,
                        /\\setmonofont\b/,
                        /\\newfontfamily\b/,
                        /\\setmathfont\b/,
                        /\\defaultfontfeatures\b/
                    ],
                    // CJK, Arabic, Devanagari, Thai, Korean
                    scripts: /[\u0600-\u06FF\u0900-\u097F\u0E00-\u0E7F\u3000-\u9FFF\uAC00-\uD7AF]/
                },
                lualatex: {
                    packages: new Set([
                        'luacode', 'luatexbase', 'luaotfload', 'luamplib', 'luatextra'
                    ]),
                    commands: [
                        /\\directlua\b/,
                        /\\luaexec\b/
                    ],
                    scripts: null
                }
            };

            // Packages that PREFER XeLaTeX (avoids cm-super font issues)
            // NOTE: fontenc and inputenc are pdfLaTeX-specific, NOT XeLaTeX preferred
            const XELATEX_PREFERRED = new Set([
                'geometry', 'fancyhdr', 'titlesec', 'enumitem', 'babel'
            ]);

            // Packages that REQUIRE or strongly prefer pdfLaTeX
            const PDFLATEX_PREFERRED = new Set([
                'fontenc', 'inputenc', 'inputenx'  // These are pdfLaTeX font encoding packages
            ]);

            // Simple hash function for preamble
            function hashPreamble(preamble) {
                const normalized = preamble
                    .replace(/%.*$/gm, '')
                    .replace(/\s+/g, ' ')
                    .trim();
                let hash = 5381;
                for (let i = 0; i < normalized.length; i++) {
                    hash = ((hash << 5) + hash) + normalized.charCodeAt(i);
                    hash = hash & hash;
                }
                return 'p_' + Math.abs(hash).toString(36);
            }

            // Extract preamble (before \begin{document})
            function extractPreamble(source) {
                const match = source.match(/^([\s\S]*?)\\begin\{document\}/);
                return match ? match[1] : source.slice(0, 2000);
            }

            // Extract packages from source
            function extractPackages(source) {
                const packages = [];
                // Match \documentclass{class} and \documentclass[opts]{class}
                const documentclassRegex = /\\documentclass(?:\[[^\]]*\])?\{([^}]+)\}/g;
                let match;
                while ((match = documentclassRegex.exec(source)) !== null) {
                    const className = match[1].trim();
                    // Skip standard classes
                    const standardClasses = ['article', 'report', 'book', 'letter', 'slides', 'minimal', 'proc', 'ltxdoc', 'ltxguide'];
                    if (!standardClasses.includes(className)) {
                        packages.push(className);
                    }
                }
                // Match \usepackage{pkg} and \usepackage[opts]{pkg}
                const usepackageRegex = /\\usepackage(?:\[.*?\])?\{([^}]+)\}/g;
                while ((match = usepackageRegex.exec(source)) !== null) {
                    packages.push(...match[1].split(',').map(p => p.trim()));
                }
                // Also match \input{pkg} - some packages use this (e.g., fullpage)
                const inputRegex = /\\input\{([^}]+)\}/g;
                while ((match = inputRegex.exec(source)) !== null) {
                    // Only add if it looks like a package name (no path separators, no extension or .sty)
                    const name = match[1].trim();
                    if (!name.includes('/') && !name.includes('\\')) {
                        packages.push(name.replace(/\.sty$/, ''));
                    }
                }
                return packages;
            }

            // Get stats from localStorage
            function getStats(preambleHash) {
                try {
                    const data = localStorage.getItem(STORAGE_PREFIX + 'stats_' + preambleHash);
                    return data ? JSON.parse(data) : null;
                } catch { return null; }
            }

            // Save stats to localStorage
            function saveStats(preambleHash, stats) {
                try {
                    localStorage.setItem(STORAGE_PREFIX + 'stats_' + preambleHash, JSON.stringify(stats));
                } catch {}
            }

            // Check if cm-super was triggered for this preamble
            function getCmSuperFlag(preambleHash) {
                return localStorage.getItem(STORAGE_PREFIX + 'cmsuper_' + preambleHash) === 'true';
            }

            // Set cm-super flag
            function setCmSuperFlag(preambleHash) {
                try {
                    localStorage.setItem(STORAGE_PREFIX + 'cmsuper_' + preambleHash, 'true');
                } catch {}
            }

            return {
                // Main selection method
                select: function(source) {
                    const packages = extractPackages(source);
                    const preamble = extractPreamble(source);
                    const preambleHash = hashPreamble(preamble);
                    const withoutComments = source.replace(/%.*$/gm, '');

                    // 1. Check hard requirements
                    for (const [engine, req] of Object.entries(REQUIREMENTS)) {
                        for (const pkg of packages) {
                            if (req.packages.has(pkg)) {
                                return { engine, reason: `package '${pkg}' requires ${engine}`, confidence: 'high' };
                            }
                        }
                        for (const cmd of req.commands) {
                            if (cmd.test(withoutComments)) {
                                return { engine, reason: `command requires ${engine}`, confidence: 'high' };
                            }
                        }
                        if (req.scripts && req.scripts.test(withoutComments)) {
                            return { engine, reason: 'complex script detected', confidence: 'high' };
                        }
                    }

                    // 2. Check historical data
                    const stats = getStats(preambleHash);
                    if (stats && stats.length > 0) {
                        const successful = stats.filter(s => s.successRate > 0.5 && s.compileCount >= 2);
                        if (successful.length > 0) {
                            const fastest = successful.reduce((a, b) => a.avgTimeMs < b.avgTimeMs ? a : b);
                            return {
                                engine: fastest.engine,
                                reason: `learned: ${Math.round(fastest.avgTimeMs)}ms avg`,
                                confidence: 'high'
                            };
                        }
                    }

                    // 3. Check pdfLaTeX-specific packages (fontenc, inputenc, etc.)
                    // These packages are incompatible with XeLaTeX
                    for (const pkg of packages) {
                        if (PDFLATEX_PREFERRED.has(pkg)) {
                            return { engine: 'pdflatex', reason: `'${pkg}' requires pdflatex`, confidence: 'high' };
                        }
                    }

                    // 4. Check cm-super flag (learned from past)
                    if (getCmSuperFlag(preambleHash)) {
                        return { engine: 'xelatex', reason: 'avoids cm-super (learned)', confidence: 'high' };
                    }

                    // 5. Check preferences (packages that often trigger cm-super)
                    for (const pkg of packages) {
                        if (XELATEX_PREFERRED.has(pkg)) {
                            return { engine: 'xelatex', reason: `'${pkg}' prefers xelatex`, confidence: 'medium' };
                        }
                    }

                    // 6. Default: pdflatex (fastest for simple docs)
                    return { engine: 'pdflatex', reason: 'default (fastest)', confidence: 'low' };
                },

                // Record compile result for learning
                recordResult: function(source, result) {
                    const preamble = extractPreamble(source);
                    const preambleHash = hashPreamble(preamble);

                    // Update stats
                    let stats = getStats(preambleHash) || [];
                    let engineStats = stats.find(s => s.engine === result.engine);

                    if (!engineStats) {
                        engineStats = {
                            engine: result.engine,
                            compileCount: 0,
                            avgTimeMs: 0,
                            successRate: 0,
                            lastUsed: Date.now()
                        };
                        stats.push(engineStats);
                    }

                    const n = engineStats.compileCount;
                    engineStats.avgTimeMs = (engineStats.avgTimeMs * n + result.timeMs) / (n + 1);
                    engineStats.successRate = (engineStats.successRate * n + (result.success ? 1 : 0)) / (n + 1);
                    engineStats.compileCount++;
                    engineStats.lastUsed = Date.now();

                    saveStats(preambleHash, stats);

                    // Flag cm-super trigger
                    if (result.triggeredCmSuper && result.engine === 'pdflatex') {
                        setCmSuperFlag(preambleHash);
                    }
                },

                // Clear all learned data
                clearHistory: function() {
                    const keys = Object.keys(localStorage).filter(k => k.startsWith(STORAGE_PREFIX));
                    keys.forEach(k => localStorage.removeItem(k));
                },

                // For debugging
                getDebugInfo: function(source) {
                    const preamble = extractPreamble(source);
                    const preambleHash = hashPreamble(preamble);
                    return {
                        preambleHash,
                        stats: getStats(preambleHash),
                        cmSuperFlag: getCmSuperFlag(preambleHash),
                        packages: extractPackages(source)
                    };
                }
            };
        })();

        // Track if cm-super was fetched this compile
        let triggeredCmSuper = false;

        // Wrapper for backward compatibility
        function detectEngine(source) {
            return EngineSelector.select(source);
        }

        function getSelectedEngine(source = null) {
            const selection = document.getElementById('engineSelect').value;
            if (selection !== 'auto') {
                return selection;
            }
            if (!source) {
                source = document.getElementById('source').value;
            }
            return EngineSelector.select(source).engine;
        }

        function getEngineWithReason(source) {
            const selection = document.getElementById('engineSelect').value;
            if (selection !== 'auto') {
                return { engine: selection, reason: 'manual selection' };
            }
            return detectEngine(source);
        }

        function log(msg) {
            const status = document.getElementById('status');
            status.textContent += '\n' + msg;
            status.scrollTop = status.scrollHeight;
            console.log(msg);
        }

        function updateStats() {
            document.getElementById('fileCount').textContent = filesFetched;
            document.getElementById('bytesDownloaded').textContent = (bytesDownloaded / 1024).toFixed(1);
            document.getElementById('requestCount').textContent = requestCount;
            document.getElementById('ctanCount').textContent = ctanFetchCount;
            document.getElementById('cacheHits').textContent = cacheHitCount;
            document.getElementById('lazyLoads').textContent = lazyLoadCount;
        }

        async function loadManifest() {
            if (fileManifest) return fileManifest;
            log('Loading file manifest...');
            const cacheBust = `?t=${Date.now()}`;
            const response = await fetch(`${BUNDLE_BASE}/file-manifest.json${cacheBust}`);
            fileManifest = await response.json();
            log(`Manifest loaded: ${Object.keys(fileManifest).length} files indexed`);

            // Build a set of .sty/.cls/.def filenames from bundles for duplicate detection
            // This prevents CTAN versions (at different paths) from overwriting bundle versions
            bundleFilenames = new Set();
            for (const fullPath of Object.keys(fileManifest)) {
                if (fullPath.includes('/tex/') && (
                    fullPath.endsWith('.sty') ||
                    fullPath.endsWith('.cls') ||
                    fullPath.endsWith('.def') ||
                    fullPath.endsWith('.clo')
                )) {
                    const filename = fullPath.substring(fullPath.lastIndexOf('/') + 1);
                    bundleFilenames.add(filename);
                }
            }

            return fileManifest;
        }

        async function loadBundleDeps() {
            if (bundleDeps) return bundleDeps;
            const cacheBust = `?t=${Date.now()}`;
            const [depsResponse, mapResponse, registryResponse, pkgDepsResponse] = await Promise.all([
                fetch(`${BUNDLE_BASE}/bundle-deps.json${cacheBust}`),
                fetch(`${BUNDLE_BASE}/package-map.json${cacheBust}`),
                fetch(`${BUNDLE_BASE}/registry.json${cacheBust}`),
                fetch(`${BUNDLE_BASE}/package-deps.json${cacheBust}`)
            ]);
            bundleDeps = await depsResponse.json();
            packageMap = await mapResponse.json();
            bundleRegistry = new Set((await registryResponse.json()).map(b => b.name));
            const pkgDepsData = await pkgDepsResponse.json();
            packageDeps = pkgDepsData.packages || {};  // Map: packageName -> [dep1, dep2, ...]
            return bundleDeps;
        }

        // Check if a bundle actually exists
        function bundleExists(bundleName) {
            return bundleRegistry && bundleRegistry.has(bundleName);
        }

        // Resolve all bundles needed for a set of packages
        function resolveBundles(packages, engine = 'xelatex') {
            const bundles = new Set();
            const visitedBundles = new Set();
            const visitedPackages = new Set();  // Track visited packages to avoid infinite loops
            const missingPackages = [];
            const missingBundles = [];  // Bundles that don't exist but are in deps

            // Recursive function to resolve bundle dependencies (bundle-level)
            function addBundle(bundleName) {
                if (visitedBundles.has(bundleName)) return;
                visitedBundles.add(bundleName);

                // Only add if bundle actually exists
                if (bundleExists(bundleName)) {
                    bundles.add(bundleName);
                } else {
                    // Bundle doesn't exist - treat as a package to fetch from CTAN
                    if (!missingPackages.includes(bundleName) && !missingBundles.includes(bundleName)) {
                        missingBundles.push(bundleName);
                    }
                }

                // Check if this bundle has dependencies (from bundle-deps.json)
                const deps = bundleDeps.bundles[bundleName];
                if (deps && deps.requires) {
                    deps.requires.forEach(dep => addBundle(dep));
                }
            }

            // Recursive function to resolve package dependencies (package-level)
            function addPackage(pkgName) {
                if (visitedPackages.has(pkgName)) return;
                visitedPackages.add(pkgName);

                // Find the bundle for this package
                const bundleName = packageMap[pkgName];
                if (bundleName) {
                    addBundle(bundleName);
                }
                // Note: if no bundle found, it will be handled below when we track missing packages

                // Resolve package-level dependencies (from package-deps.json)
                const pkgDepsList = packageDeps && packageDeps[pkgName];
                if (pkgDepsList) {
                    for (const depPkg of pkgDepsList) {
                        addPackage(depPkg);
                    }
                }
            }

            // Add engine requirements (using addBundle to resolve their dependencies)
            const engineDeps = bundleDeps.engines[engine];
            if (engineDeps) {
                engineDeps.required.forEach(b => addBundle(b));
            }

            // For each package, resolve its dependencies and bundles
            for (const pkg of packages) {
                if (packageMap[pkg]) {
                    addPackage(pkg);
                } else {
                    // Package not found in any bundle
                    if (!missingPackages.includes(pkg)) {
                        missingPackages.push(pkg);
                    }
                }
            }

            // Combine missing bundles into missing packages (they might be package names)
            const allMissing = [...new Set([...missingPackages, ...missingBundles])];

            return { bundles: [...bundles], missingPackages: allMissing };
        }

        // Check packages before compilation
        function checkPackages(source, engine = 'xelatex') {
            const packages = [];
            // Match \documentclass{class} and \documentclass[opts]{class}
            // Document classes are essentially packages and may need to be fetched
            const documentclassRegex = /\\documentclass(?:\[[^\]]*\])?\{([^}]+)\}/g;
            let match;
            while ((match = documentclassRegex.exec(source)) !== null) {
                const className = match[1].trim();
                // Skip standard classes that are always available
                const standardClasses = ['article', 'report', 'book', 'letter', 'slides', 'minimal', 'proc', 'ltxdoc', 'ltxguide'];
                if (!standardClasses.includes(className)) {
                    packages.push(className);
                }
            }
            // Match \usepackage{pkg} and \usepackage[opts]{pkg}
            const usepackageRegex = /\\usepackage(?:\[.*?\])?\{([^}]+)\}/g;
            while ((match = usepackageRegex.exec(source)) !== null) {
                match[1].split(',').forEach(pkg => packages.push(pkg.trim()));
            }
            // Also match \input{pkg} - some packages use this (e.g., fullpage)
            const inputRegex = /\\input\{([^}]+)\}/g;
            while ((match = inputRegex.exec(source)) !== null) {
                const name = match[1].trim();
                if (!name.includes('/') && !name.includes('\\')) {
                    packages.push(name.replace(/\.sty$/, ''));
                }
            }

            const missingDiv = document.getElementById('missingPackages');
            const { bundles, missingPackages } = resolveBundles(packages, engine);

            if (missingPackages.length > 0) {
                const enableCtan = document.getElementById('enableCtan').checked;
                if (enableCtan) {
                    missingDiv.innerHTML = `
                        <div class="warning">
                            Packages not in local bundles (will try CTAN): <strong>${missingPackages.join(', ')}</strong>
                        </div>`;
                } else {
                    missingDiv.innerHTML = `
                        <div class="warning missing-pkg">
                            Missing packages (CTAN fetch disabled): <strong>${missingPackages.join(', ')}</strong>
                        </div>`;
                }
            } else {
                missingDiv.innerHTML = '';
            }

            return { packages, bundles, missingPackages };
        }

        // Check if a package file exists in the filesystem
        // Returns the path where it was found, or null if not found
        function packageExistsInFS(FS, packageName) {
            const possiblePaths = [
                `/texlive/texmf-dist/tex/latex/${packageName}/${packageName}.sty`,
                `/texlive/texmf-dist/tex/latex/${packageName}.sty`,
                `/texlive/texmf-dist/tex/generic/${packageName}/${packageName}.sty`,
                `/texlive/texmf-dist/tex/generic/${packageName}.sty`,
                // l3packages have a different structure
                `/texlive/texmf-dist/tex/latex/l3packages/${packageName}/${packageName}.sty`,
                `/texlive/texmf-dist/tex/latex/l3kernel/${packageName}.sty`,
                // Also check .cls for document classes
                `/texlive/texmf-dist/tex/latex/${packageName}/${packageName}.cls`,
                `/texlive/texmf-dist/tex/latex/${packageName}.cls`,
            ];
            for (const path of possiblePaths) {
                try {
                    if (FS.analyzePath(path).exists) return path;
                } catch (e) {}
            }
            // Also check by scanning all latex dirs (slower fallback)
            try {
                const latexDir = '/texlive/texmf-dist/tex/latex';
                const dirs = FS.readdir(latexDir);
                for (const dir of dirs) {
                    if (dir === '.' || dir === '..') continue;
                    try {
                        const styPath = `${latexDir}/${dir}/${packageName}.sty`;
                        if (FS.analyzePath(styPath).exists) return styPath;
                        const clsPath = `${latexDir}/${dir}/${packageName}.cls`;
                        if (FS.analyzePath(clsPath).exists) return clsPath;
                    } catch (e) {}
                }
            } catch (e) {}
            return null;  // Not found
        }

        // Append font map files from a CTAN package to pdftex.map
        // This allows pdfTeX to find font mappings from dynamically loaded font packages
        async function appendFontMapsToUpdmap(FS, files) {
            const PDFTEX_MAP_PATH = '/texlive/texmf-dist/texmf-var/fonts/map/pdftex/updmap/pdftex.map';

            // Find all .map files in the package (excluding pdftex.map itself)
            const mapFiles = Object.entries(files).filter(([path, info]) =>
                path.endsWith('.map') && !path.includes('pdftex.map')
            );

            if (mapFiles.length === 0) return;

            // Track map file paths for re-appending after WASM reinit
            for (const [path] of mapFiles) {
                ctanFontMapFiles.add(path);
            }

            try {
                // Read existing pdftex.map
                let existingMap = '';
                try {
                    existingMap = new TextDecoder().decode(FS.readFile(PDFTEX_MAP_PATH));
                } catch (e) {
                    log('    Warning: pdftex.map not found, cannot append font maps');
                    return;
                }

                // Append each map file's content with absolute paths
                let appendedContent = '';
                for (const [path, info] of mapFiles) {
                    try {
                        let content;
                        if (info.encoding === 'base64') {
                            content = atob(info.content);
                        } else if (typeof info.content === 'string') {
                            content = info.content;
                        } else {
                            // Read from filesystem
                            content = new TextDecoder().decode(FS.readFile(path));
                        }

                        // Rewrite file references to use absolute paths
                        // This bypasses kpathsea which doesn't work reliably in WASM
                        const rewrittenContent = rewriteMapWithAbsolutePaths(content, FS, path);

                        // Add header comment and content
                        const mapName = path.split('/').pop();
                        appendedContent += `\n% === Appended from ${mapName} (with absolute paths) ===\n`;
                        appendedContent += rewrittenContent;
                        log(`    Appended font map: ${mapName} (with absolute paths)`);

                        // Debug: show sample of rewritten entries for tcrm1000
                        const tcrm = rewrittenContent.split('\n').find(l => l.startsWith('tcrm1000'));
                        if (tcrm) {
                            log(`    DEBUG full tcrm1000 entry: ${tcrm}`);
                        }
                    } catch (e) {
                        console.warn(`Failed to read map file ${path}:`, e);
                    }
                }

                if (appendedContent) {
                    // Write back with appended content
                    const newMap = existingMap + appendedContent;
                    FS.writeFile(PDFTEX_MAP_PATH, newMap);
                    // Debug: verify the tcrm1000 entry in the final pdftex.map
                    try {
                        const finalMap = new TextDecoder().decode(FS.readFile(PDFTEX_MAP_PATH));
                        const finalTcrm = finalMap.split('\n').find(l => l.startsWith('tcrm1000'));
                        if (finalTcrm) {
                            log(`    DEBUG tcrm1000 in final pdftex.map: ${finalTcrm}`);
                        }
                    } catch(e) {}
                }
            } catch (e) {
                console.warn('Failed to append font maps:', e);
            }
        }

        // Copy .enc files from fonts/type1/ to fonts/enc/ where kpathsea expects them
        // CTAN packages like cm-super put .enc files in type1/ but kpathsea searches enc/
        function copyEncFilesToStandardLocation(FS, files) {
            const ENC_STANDARD_BASE = '/texlive/texmf-dist/fonts/enc/dvips';

            // Find all .enc files that are in fonts/type1/
            const encInType1 = Object.keys(files).filter(path =>
                path.endsWith('.enc') && path.includes('/fonts/type1/')
            );

            if (encInType1.length === 0) return;

            let copied = 0;
            for (const srcPath of encInType1) {
                try {
                    // Extract package name from path like /texlive/texmf-dist/fonts/type1/public/cm-super/foo.enc
                    const match = srcPath.match(/\/fonts\/type1\/public\/([^/]+)\//);
                    if (!match) continue;

                    const pkgName = match[1];
                    const fileName = srcPath.split('/').pop();
                    const destDir = `${ENC_STANDARD_BASE}/${pkgName}`;
                    const destPath = `${destDir}/${fileName}`;

                    // Create destination directory
                    ensureDirectory(FS, destDir);

                    // Copy the file
                    const content = FS.readFile(srcPath);
                    FS.writeFile(destPath, content);
                    ctanMountedFiles.add(destPath);  // Track for ls-R
                    copied++;
                } catch (e) {
                    // Ignore errors - file might not be mounted yet from cache
                }
            }

            if (copied > 0) {
                log(`    Copied ${copied} .enc files to standard location`);
            }
        }

        // Validate package names - filters out LaTeX macro artifacts like #2, \@tempb, %, etc.
        function isValidPackageName(name) {
            if (!name || name.length === 0) return false;
            // Must start with a letter, can contain letters, numbers, and hyphens
            // Filter out: # (macro args), \ (commands), @ (internal), % (comments), spaces
            return /^[a-zA-Z][a-zA-Z0-9\-]*$/.test(name);
        }

        // Download package from CTAN via proxy and mount to filesystem
        // Recursively fetches dependencies detected by scanning \RequirePackage
        // Uses browser cache (IDB + OPFS) to avoid re-downloading
        async function downloadAndMountCTANPackage(packageName, FS, fetchedSet = new Set()) {
            // Skip invalid package names (LaTeX macro artifacts)
            if (!isValidPackageName(packageName)) {
                return false;
            }

            // Track cm-super for engine learning
            if (packageName === 'cm-super') {
                triggeredCmSuper = true;
            }

            // Skip if already fetched
            if (fetchedSet.has(packageName)) return true;

            // Check if package already exists in the filesystem (from bundles or previous CTAN fetch)
            const existingPath = packageExistsInFS(FS, packageName);
            if (existingPath) {
                log(`    Skipping ${packageName} (found at ${existingPath})`);
                fetchedSet.add(packageName);
                return true;
            }

            fetchedSet.add(packageName);

            // Try loading from browser cache first (IDB metadata + OPFS files)
            const cached = await loadPackageFromCache(packageName, FS);
            if (cached && cached.mounted > 0) {
                // Successfully loaded from cache - process dependencies
                if (cached.dependencies && cached.dependencies.length > 0) {
                    const newDeps = cached.dependencies.filter(d => !fetchedSet.has(d));
                    if (newDeps.length > 0) {
                        log(`    Cached dependencies: ${newDeps.join(', ')}`);
                        for (const dep of newDeps) {
                            await downloadAndMountCTANPackage(dep, FS, fetchedSet);
                        }
                    }
                }
                return true;
            }

            // Not in cache - fetch from CTAN proxy
            log(`  Fetching from CTAN: ${packageName}`);
            ctanFetchCount++;
            updateStats();

            try {
                const response = await fetch(`${CTAN_PROXY}/api/fetch/${packageName}`);
                if (!response.ok) {
                    const err = await response.json().catch(() => ({}));
                    log(`    CTAN error: ${err.error || response.status}`);
                    // Cache "not found" to avoid re-fetching on next compile
                    if (response.status === 404) {
                        await savePackageMeta(packageName, {
                            notFound: true,
                            cacheVersion: CTAN_CACHE_VERSION
                        });
                    }
                    return false;
                }

                const data = await response.json();
                if (data.error) {
                    log(`    Not found: ${data.error}`);
                    // Cache "not found" to avoid re-fetching on next compile
                    await savePackageMeta(packageName, {
                        notFound: true,
                        cacheVersion: CTAN_CACHE_VERSION
                    });
                    return false;
                }

                // Track the actual package name returned (handles aliases like pgfkeys -> pgf)
                const actualPkgName = data.name || packageName;
                if (actualPkgName !== packageName) {
                    // Save alias so future lookups find the right cache entry
                    await savePackageMeta(packageName, {
                        aliasFor: actualPkgName,
                        cacheVersion: CTAN_CACHE_VERSION
                    });
                    if (fetchedSet.has(actualPkgName)) {
                        log(`    Skipping (${actualPkgName} already fetched)`);
                        return true;
                    }
                    fetchedSet.add(actualPkgName);
                }

                // Mount files to filesystem (skip files that already exist from bundles)
                let mounted = 0;
                let skipped = 0;
                for (const [fullPath, fileInfo] of Object.entries(data.files)) {
                    const { path: dirPath, content, encoding } = fileInfo;

                    // CRITICAL: Don't overwrite files from bundles!
                    // CTAN packages may have newer incompatible versions
                    // Check fileManifest first (lazy stubs aren't detected by analyzePath)
                    if (fileManifest[fullPath]) {
                        skipped++;
                        continue;  // Skip - bundle version takes precedence
                    }

                    // Also check if this file exists in bundles at a different path
                    // CTAN may use different directory names (e.g., latex-tools vs tools)
                    const filename = fullPath.substring(fullPath.lastIndexOf('/') + 1);
                    if (bundleFilenames && bundleFilenames.has(filename) && fullPath.includes('/tex/')) {
                        skipped++;
                        continue;  // Skip - bundle has this file at a different path
                    }

                    try {
                        if (FS.analyzePath(fullPath).exists) {
                            skipped++;
                            continue;  // Skip - already mounted
                        }
                    } catch (e) {}

                    ensureDirectory(FS, dirPath);
                    try {
                        let fileContent = content;
                        if (encoding === 'base64') {
                            // Decode base64 binary content (fonts, etc.)
                            const binaryString = atob(content);
                            const bytes = new Uint8Array(binaryString.length);
                            for (let i = 0; i < binaryString.length; i++) {
                                bytes[i] = binaryString.charCodeAt(i);
                            }
                            fileContent = bytes;
                        } else if (Array.isArray(content)) {
                            // Legacy: Convert array to Uint8Array for binary files
                            fileContent = new Uint8Array(content);
                        }
                        FS.writeFile(fullPath, fileContent);
                        ctanMountedFiles.add(fullPath);  // Track for ls-R
                        mounted++;
                    } catch (e) {
                        console.warn(`Failed to mount ${fullPath}:`, e);
                    }
                }

                requestCount++;
                updateStats();
                log(`    Mounted ${mounted} files` + (skipped > 0 ? ` (${skipped} skipped - already exist)` : ''));

                // If this is a font package with .map files, append them to pdftex.map
                await appendFontMapsToUpdmap(FS, data.files);

                // Copy .enc files from type1/ to enc/ where kpathsea expects them
                copyEncFilesToStandardLocation(FS, data.files);

                // Save to browser cache (IDB + OPFS) for future runs
                await savePackageToCache(actualPkgName, data.files, data.dependencies || []);

                // Recursively fetch dependencies detected from \RequirePackage
                if (data.dependencies && data.dependencies.length > 0) {
                    const newDeps = data.dependencies.filter(d => !fetchedSet.has(d));
                    if (newDeps.length > 0) {
                        log(`    Dependencies: ${newDeps.join(', ')}`);
                        for (const dep of newDeps) {
                            await downloadAndMountCTANPackage(dep, FS, fetchedSet);
                        }
                    }
                }

                return mounted > 0;

            } catch (e) {
                log(`    CTAN fetch failed: ${e.message}`);
                log(`    (Make sure ctan-proxy.ts is running on port 8081)`);
                return false;
            }
        }

        async function decompress(compressed) {
            const stream = new Response(compressed).body.pipeThrough(new DecompressionStream('gzip'));
            return await new Response(stream).arrayBuffer();
        }

        // Check bundle cache version and clear if stale
        let bundleCacheVersionChecked = false;
        async function checkBundleCacheVersion() {
            if (bundleCacheVersionChecked) return;
            bundleCacheVersionChecked = true;

            try {
                const root = await getOPFSRoot();
                if (!root) return;

                // Check if bundles directory exists
                let bundlesDir;
                try {
                    bundlesDir = await root.getDirectoryHandle('bundles', { create: false });
                } catch (e) {
                    return;  // No bundles directory = nothing to clear
                }

                // Check version file
                let storedVersion = 0;  // Treat missing/unreadable as version 0 (stale)
                try {
                    const versionHandle = await bundlesDir.getFileHandle('version', { create: false });
                    const versionFile = await versionHandle.getFile();
                    storedVersion = parseInt(await versionFile.text(), 10) || 0;
                } catch (e) {
                    // No version file = old cache without versioning (version 0)
                }

                if (storedVersion !== BUNDLE_CACHE_VERSION) {
                    log(`Bundle cache version mismatch (${storedVersion} vs ${BUNDLE_CACHE_VERSION}), clearing...`);
                    await clearBundleCache();
                }
            } catch (e) {
                // OPFS not available
            }
        }

        // Clear all bundles from OPFS cache
        async function clearBundleCache() {
            try {
                const root = await getOPFSRoot();
                if (!root) return;

                await root.removeEntry('bundles', { recursive: true });
                log('  Cleared OPFS bundle cache');
            } catch (e) {
                // Ignore - directory might not exist
            }
        }

        // Check if bundle exists in OPFS cache
        async function getBundleFromOPFS(bundleName) {
            try {
                // Check version first (only once per session)
                await checkBundleCacheVersion();

                const root = await getOPFSRoot();
                if (!root) return null;

                const bundlesDir = await root.getDirectoryHandle('bundles', { create: false });
                const fileHandle = await bundlesDir.getFileHandle(`${bundleName}.data`, { create: false });
                const file = await fileHandle.getFile();
                return await file.arrayBuffer();
            } catch (e) {
                return null;  // Not cached
            }
        }

        // Save bundle to OPFS cache
        async function saveBundleToOPFS(bundleName, data) {
            try {
                const root = await getOPFSRoot();
                if (!root) {
                    console.warn('OPFS root not available for saving bundle');
                    return false;
                }

                const bundlesDir = await root.getDirectoryHandle('bundles', { create: true });

                // Save version file (always update to current version)
                const versionHandle = await bundlesDir.getFileHandle('version', { create: true });
                const versionWritable = await versionHandle.createWritable();
                await versionWritable.write(String(BUNDLE_CACHE_VERSION));
                await versionWritable.close();

                const fileHandle = await bundlesDir.getFileHandle(`${bundleName}.data`, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(data);
                await writable.close();
                return true;
            } catch (e) {
                console.warn(`Failed to cache bundle ${bundleName}:`, e);
                return false;
            }
        }

        async function loadBundle(bundleName) {
            // Check in-memory cache first (instant, no I/O)
            if (bundleCache.has(bundleName)) {
                return bundleCache.get(bundleName);
            }

            // Check OPFS cache (persists across page loads)
            const cached = await getBundleFromOPFS(bundleName);
            if (cached) {
                log(`  From OPFS: ${bundleName}`);
                bundleCache.set(bundleName, cached);
                cacheHitCount++;
                updateStats();
                return cached;
            }

            // Fetch from server
            const url = `${BUNDLE_BASE}/${bundleName}.data.gz`;
            log(`  Fetching: ${bundleName}`);
            requestCount++;

            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load ${bundleName}: ${response.status}`);

            const compressed = await response.arrayBuffer();
            bytesDownloaded += compressed.byteLength;

            const decompressed = await decompress(compressed);
            bundleCache.set(bundleName, decompressed);

            // Save to OPFS for future sessions (don't await - do in background)
            saveBundleToOPFS(bundleName, decompressed);

            updateStats();
            return decompressed;
        }

        function ensureDirectory(FS, dirPath) {
            const parts = dirPath.split('/').filter(p => p);
            let current = '';
            for (const part of parts) {
                current += '/' + part;
                try { FS.mkdir(current); } catch (e) {}
            }
        }

        // Create a fresh WASM module for each compile (to reset memory)
        // Uses cached WebAssembly.Module to skip recompilation on subsequent runs
        async function initBusyTeX(forceNew = false) {
            // Reuse existing module if not forcing new
            if (busytexModule && !forceNew) return busytexModule;

            // Load the script once
            if (!busytexScriptLoaded) {
                log('Loading BusyTeX WASM...');
                await new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'busytex.js';
                    script.onload = resolve;
                    script.onerror = reject;
                    document.head.appendChild(script);
                });
                busytexScriptLoaded = true;
            } else if (forceNew) {
                log('Reinitializing WASM module...');
            }

            const initStart = performance.now();

            const Module = {
                thisProgram: '/bin/busytex',
                noInitialRun: true,
                noExitRuntime: true,
                locateFile: (path) => path.endsWith('.wasm') ? 'busytex.wasm' : path,
                print: (text) => { console.log('[busytex]', text); },
                printErr: (text) => { console.log('[busytex-err]', text); },

                // Custom WASM instantiation - cache the compiled module for faster re-instantiation
                instantiateWasm: async (imports, successCallback) => {
                    try {
                        let instance;

                        if (cachedWasmModule) {
                            // Fast path: reuse cached compiled module, just create new instance (resets memory)
                            log('  Using cached WASM module...');
                            instance = await WebAssembly.instantiate(cachedWasmModule, imports);
                        } else {
                            // First run: compile and cache the module
                            log('  Compiling WASM module (first run)...');
                            const wasmUrl = Module.locateFile('busytex.wasm');
                            const response = await fetch(wasmUrl);
                            const wasmBytes = await response.arrayBuffer();

                            // Compile to WebAssembly.Module (this is the slow step)
                            cachedWasmModule = await WebAssembly.compile(wasmBytes);

                            // Instantiate from compiled module
                            instance = await WebAssembly.instantiate(cachedWasmModule, imports);
                        }

                        successCallback(instance);
                        return instance.exports;
                    } catch (e) {
                        console.error('WASM instantiation failed:', e);
                        throw e;
                    }
                },

                preRun: [() => {
                    Module.ENV = Module.ENV || {};
                    Module.ENV['TEXMFCNF'] = '/texlive/texmf-dist/web2c';
                    Module.ENV['TEXMFROOT'] = '/texlive';
                    Module.ENV['TEXMFDIST'] = '/texlive/texmf-dist';
                    Module.ENV['TEXMFVAR'] = '/texlive/texmf-dist/texmf-var';
                    Module.ENV['TEXMFSYSVAR'] = '/texlive/texmf-dist/texmf-var';
                    Module.ENV['TEXMF'] = '/texlive/texmf-dist';
                    Module.ENV['TEXINPUTS'] = '.:/texlive/texmf-dist/tex/latex//:/texlive/texmf-dist/tex/xetex//:/texlive/texmf-dist/tex/generic//:/texlive/texmf-dist/tex//:';
                    // Explicit paths for Type1 fonts - needed for CTAN packages like cm-super
                    // Include both the recursive // search and explicit cm-super path as fallback
                    Module.ENV['T1FONTS'] = '.:/texlive/texmf-dist/fonts/type1/public/cm-super:/texlive/texmf-dist/fonts/type1//';
                    // Explicit paths for encoding files - cm-super puts .enc in type1/ but we copy to enc/
                    Module.ENV['ENCFONTS'] = '.:/texlive/texmf-dist/fonts/enc/dvips/cm-super:/texlive/texmf-dist/fonts/type1/public/cm-super:/texlive/texmf-dist/fonts/enc//';
                }],

                setPrefix(prefix) {
                    Module.thisProgram = '/bin/' + prefix;
                },

                callMainWithRedirects(args = [], print = false) {
                    Module.do_print = print;
                    Module.output_stdout = '';
                    Module.output_stderr = '';
                    if (args.length > 0) Module.setPrefix(args[0]);
                    const exit_code = Module.callMain(args);
                    Module._flush_streams();
                    return { exit_code, stdout: Module.output_stdout, stderr: Module.output_stderr };
                }
            };

            busytexModule = await busytex(Module);
            const initTime = performance.now() - initStart;
            log(`WASM init: ${initTime.toFixed(0)}ms`);
            return busytexModule;
        }

        // Generate ls-R database for kpathsea to find files
        // Optimized version: builds from manifest instead of walking FS tree
        function generateLsR(FS, basePath) {
            // Build directory structure - use arrays instead of Sets for faster iteration
            const dirContents = new Map();  // dir -> { files: [], subdirs: [] }
            const seenDirs = new Set();     // Track directories we've already registered

            // Ensure base path entry exists
            dirContents.set(basePath, { files: [], subdirs: [] });

            // Helper to get or create directory entry
            function getDir(dirPath) {
                if (!dirContents.has(dirPath)) {
                    dirContents.set(dirPath, { files: [], subdirs: [] });
                }
                return dirContents.get(dirPath);
            }

            // Helper to ensure directory chain exists
            function ensureDirChain(dirPath) {
                if (seenDirs.has(dirPath) || dirPath.length <= basePath.length) return;
                seenDirs.add(dirPath);

                getDir(dirPath);  // Ensure this dir exists

                // Register with parent
                const parentSlash = dirPath.lastIndexOf('/');
                if (parentSlash > basePath.length) {
                    const parentDir = dirPath.substring(0, parentSlash);
                    const subdir = dirPath.substring(parentSlash + 1);
                    ensureDirChain(parentDir);  // Ensure parent exists first
                    getDir(parentDir).subdirs.push(subdir);
                } else if (parentSlash >= 0) {
                    // Direct child of basePath
                    const subdir = dirPath.substring(parentSlash + 1);
                    getDir(basePath).subdirs.push(subdir);
                }
            }

            // Process all manifest files
            for (const path of Object.keys(fileManifest)) {
                if (!path.startsWith(basePath)) continue;
                const lastSlash = path.lastIndexOf('/');
                if (lastSlash < 0) continue;  // Skip malformed paths
                const dirPath = path.substring(0, lastSlash);
                const fileName = path.substring(lastSlash + 1);
                if (!dirPath || !fileName) continue;  // Skip empty

                ensureDirChain(dirPath);
                const dir = getDir(dirPath);
                if (dir && dir.files) dir.files.push(fileName);
            }

            // Add CTAN-mounted files
            for (const path of ctanMountedFiles) {
                if (!path.startsWith(basePath)) continue;
                const lastSlash = path.lastIndexOf('/');
                if (lastSlash < 0) continue;  // Skip malformed paths
                const dirPath = path.substring(0, lastSlash);
                const fileName = path.substring(lastSlash + 1);
                if (!dirPath || !fileName) continue;  // Skip empty

                ensureDirChain(dirPath);
                const dir = getDir(dirPath);
                if (dir && dir.files) dir.files.push(fileName);
            }

            // Build output - sort once per directory
            const output = ['% ls-R -- generated by lazy bundle loader', '% ' + new Date().toISOString(), ''];

            function outputDir(dirPath) {
                const contents = dirContents.get(dirPath);
                if (!contents) return;

                output.push(dirPath + ':');

                // Sort once, then output files and subdirs
                contents.files.sort();
                contents.subdirs.sort();

                for (const file of contents.files) output.push(file);
                for (const subdir of contents.subdirs) output.push(subdir);
                output.push('');

                // Recurse (already sorted)
                for (const subdir of contents.subdirs) {
                    outputDir(dirPath + '/' + subdir);
                }
            }

            outputDir(basePath);
            return output.join('\n');
        }

        // Mount all files from a bundle (skip if already mounted)
        async function mountBundle(FS, bundleName) {
            if (mountedBundles.has(bundleName)) {
                return 0;  // Already mounted to this MEMFS instance
            }

            const bundleData = await loadBundle(bundleName);
            const dataView = new Uint8Array(bundleData);

            // Find all files in this bundle from manifest
            let mounted = 0;
            for (const [path, info] of Object.entries(fileManifest)) {
                if (info.bundle === bundleName) {
                    const dirPath = path.substring(0, path.lastIndexOf('/'));
                    ensureDirectory(FS, dirPath);
                    const fileData = dataView.slice(info.start, info.end);
                    try {
                        FS.writeFile(path, fileData);
                        mounted++;
                    } catch (e) {}
                }
            }
            filesFetched += mounted;
            mountedBundles.add(bundleName);
            return mounted;
        }

        // =============================================================================
        // LAZY FILE SYSTEM - Only load file contents on-demand
        // =============================================================================

        // Create a lazy content wrapper that loads data on first access
        // Returns a real Uint8Array after first access for full compatibility
        function createLazyContent(bundleName, start, end) {
            const size = end - start;

            // We need to return something that MEMFS can work with
            // The trick: use a Proxy on a real Uint8Array placeholder
            // When any property is accessed, we swap in the real data

            const placeholder = new Uint8Array(0);  // Empty placeholder
            let loaded = false;
            let realData = null;

            return new Proxy(placeholder, {
                get(target, prop, receiver) {
                    // Load on first access
                    if (!loaded) {
                        const loadStart = performance.now();
                        const bundleData = bundleCache.get(bundleName);
                        if (bundleData) {
                            realData = new Uint8Array(bundleData, start, size);
                            lazyLoadCount++;
                        } else {
                            realData = new Uint8Array(0);
                        }
                        loaded = true;
                        lazyLoadTotalTime += performance.now() - loadStart;
                    }

                    // Return property from real data
                    const value = realData[prop];
                    if (typeof value === 'function') {
                        return value.bind(realData);
                    }
                    return value;
                },

                set(target, prop, value) {
                    if (!loaded) {
                        const loadStart = performance.now();
                        const bundleData = bundleCache.get(bundleName);
                        if (bundleData) {
                            realData = new Uint8Array(bundleData, start, size);
                            lazyLoadCount++;
                        } else {
                            realData = new Uint8Array(0);
                        }
                        loaded = true;
                        lazyLoadTotalTime += performance.now() - loadStart;
                    }
                    realData[prop] = value;
                    return true;
                }
            });
        }

        let lazyLoadCount = 0;  // Track how many files were actually lazy-loaded
        let lazyLoadTotalTime = 0;  // Track total time spent in lazy loads

        // Cache for directory nodes to avoid repeated lookups
        let dirNodeCache = new Map();

        // Get or create directory node (cached)
        function getOrCreateDirNode(FS, dirPath) {
            if (dirNodeCache.has(dirPath)) {
                return dirNodeCache.get(dirPath);
            }

            // Ensure directory exists
            ensureDirectory(FS, dirPath);

            // Cache the node
            const node = FS.lookupPath(dirPath).node;
            dirNodeCache.set(dirPath, node);
            return node;
        }

        // Files that must be eagerly loaded (Proxy doesn't work with pdfTeX's C I/O)
        // These are critical for pdfTeX/kpathsea startup before any TeX code runs
        const EAGER_LOAD_PATTERNS = [
            /\.fmt$/,           // Format files (precompiled TeX)
            /\.map$/,           // Font map files (pdftex.map, cm.map, etc.)
            /texmf\.cnf$/,      // TeX configuration
            /ls-R$/,            // kpathsea database
            /\.cls$/,           // Document classes needed at startup
            /\.sty$/,           // Style files needed at startup
            /\.def$/,           // Definition files
            /\.clo$/,           // Class option files (size10.clo, etc.)
            /\.tfm$/,           // TeX Font Metrics (required for font loading)
            /\.pfb$/,           // Type1 PostScript fonts
            /\.enc$/,           // Font encoding files
        ];

        function shouldEagerLoad(path) {
            return EAGER_LOAD_PATTERNS.some(pattern => pattern.test(path));
        }

        // Mount files lazily - only creates stubs, content loaded on-demand
        // Critical files (format, maps, config) are loaded eagerly
        function mountBundleLazy(FS, bundleName) {
            if (mountedBundles.has(bundleName)) {
                return 0;
            }

            // Get bundle data for eager loading
            const bundleData = bundleCache.get(bundleName);
            const dataView = bundleData ? new Uint8Array(bundleData) : null;

            // Access MEMFS directly for faster node creation
            const MEMFS = FS.filesystems.MEMFS;

            let mounted = 0;
            let eagerLoaded = 0;
            for (const [path, info] of Object.entries(fileManifest)) {
                if (info.bundle === bundleName) {
                    const lastSlash = path.lastIndexOf('/');
                    const dirPath = path.substring(0, lastSlash);
                    const fileName = path.substring(lastSlash + 1);

                    try {
                        const parentNode = getOrCreateDirNode(FS, dirPath);

                        // Check if file already exists
                        if (parentNode.contents && parentNode.contents[fileName]) {
                            continue;
                        }

                        // Check if this file needs eager loading
                        if (shouldEagerLoad(path) && dataView) {
                            // EAGER: Write full content immediately
                            ensureDirectory(FS, dirPath);
                            FS.writeFile(path, dataView.slice(info.start, info.end));
                            eagerLoaded++;
                        } else {
                            // LAZY: Create node directly using MEMFS with Proxy content
                            const node = MEMFS.createNode(parentNode, fileName, 33206, 0);  // 0100666 = regular file
                            node.contents = createLazyContent(bundleName, info.start, info.end);
                            node.usedBytes = info.end - info.start;
                        }

                        mounted++;
                    } catch (e) {
                        // Silently skip errors (file exists, etc.)
                    }
                }
            }

            if (eagerLoaded > 0) {
                log(`  ${bundleName}: ${eagerLoaded} files eagerly loaded (fmt/map/cnf)`);
            }

            mountedBundles.add(bundleName);
            return mounted;
        }

        // Clean up output files between compiles (keep bundles mounted)
        function cleanWorkingFiles(FS) {
            const filesToClean = [
                '/document.tex', '/document.aux', '/document.log',
                '/document.xdv', '/document.pdf', '/document.out',
                '/document.toc', '/document.nav', '/document.snm'
            ];
            for (const file of filesToClean) {
                try { FS.unlink(file); } catch (e) {}
            }
        }

        async function compileWithLazyLoading() {
            const btn = document.getElementById('compileBtn');
            btn.disabled = true;
            btn.textContent = 'Compiling...';

            // Reset stats (but keep bundleCache for same-session reuse)
            filesFetched = 0;
            bytesDownloaded = 0;
            requestCount = 0;
            ctanFetchCount = 0;
            cacheHitCount = 0;
            lazyLoadCount = 0;
            lazyLoadTotalTime = 0;
            // Don't clear bundleCache - keep in-memory for same session
            updateStats();

            try {
                log('=== Lazy Loading Compilation ===');
                const totalStartTime = performance.now();

                // Reset cm-super tracking for this compile
                triggeredCmSuper = false;

                // Load manifest and dependency config
                await Promise.all([loadManifest(), loadBundleDeps()]);
                requestCount += 3;  // manifest + deps + package-map

                // Parse document for packages and get source
                const source = document.getElementById('source').value;

                // Get selected engine (with auto-detection)
                const { engine, reason } = getEngineWithReason(source);
                log(`Engine: ${engine} (${reason})`);

                // BREAKTHROUGH: Check document hash cache for instant results
                // If the exact same document was compiled before, return cached PDF
                const docHash = hashDocument(source);
                const cachedPdf = await getCachedPdf(docHash, engine);
                if (cachedPdf) {
                    const cacheTime = (performance.now() - totalStartTime).toFixed(0);
                    log(` INSTANT: Returning cached PDF (${cacheTime}ms)`);

                    // Use incremental PDF viewer
                    if (window.IncrementalPDFViewer) {
                        await window.IncrementalPDFViewer.render(cachedPdf);
                    }

                    document.getElementById('time').textContent = `Total: ${(cacheTime/1000).toFixed(2)}s (from cache)`;
                    log(`\nSuccess! Cached PDF: ${(cachedPdf.byteLength / 1024).toFixed(1)} KB`);
                    btn.disabled = false;
                    btn.textContent = 'Compile (Lazy Loading)';
                    return;
                }

                // ============================================================
                // WORKER PATH: Compile in Web Worker (non-blocking UI)
                // ============================================================
                const useWorker = document.getElementById('enableWorker')?.checked ?? false;
                if (useWorker) {
                    try {
                        log('Using Web Worker for compilation...');
                        const result = await compileWithWorker(source, engine);

                        if (result.success && result.pdfData) {
                            const pdfData = new Uint8Array(result.pdfData);

                            // Cache the PDF
                            await saveCachedPdf(docHash, engine, pdfData);

                            // Cache aux files
                            if (result.auxFilesToCache) {
                                const auxHash = getPreambleHashForAux(source);
                                await saveAuxCache(auxHash, { files: result.auxFilesToCache });
                            }

                            // Render PDF
                            if (window.IncrementalPDFViewer) {
                                await window.IncrementalPDFViewer.render(pdfData);
                            }

                            const totalTime = (performance.now() - totalStartTime).toFixed(0);
                            document.getElementById('time').textContent = `Total: ${(totalTime/1000).toFixed(2)}s (worker)`;
                            log(`\nSuccess! PDF: ${(pdfData.byteLength / 1024).toFixed(1)} KB`);
                            log(`Worker stats: ${result.stats?.compileTimeMs?.toFixed(0) || '?'}ms compile, ${result.stats?.lazyLoadCount || 0} lazy loads`);
                        } else {
                            log('Worker compilation failed');
                            if (result.error) log('Error: ' + result.error);
                        }
                    } catch (e) {
                        log('Worker error: ' + e.message);
                        console.error(e);
                    } finally {
                        btn.disabled = false;
                        btn.textContent = 'Compile (Lazy Loading)';
                    }
                    return;
                }

                // Check package availability
                const { packages, bundles: bundlesToLoad, missingPackages } = checkPackages(source, engine);

                log(`Detected packages: ${packages.join(', ') || '(none)'}`);
                log(`Resolved bundles: ${bundlesToLoad.join(', ')}`);

                if (missingPackages.length > 0) {
                    log(`Missing from local bundles: ${missingPackages.join(', ')}`);
                }

                // ============================================================
                // STANDARD PATH: Use pre-warmed FS state if available
                // ============================================================
                // If speculative pre-compilation ran for this preamble, we have a
                // fully-populated FS with all packages already loaded via lazy FS.
                // We can copy this state to a fresh WASM instance, skipping
                // bundle mounting and lazy loading overhead.
                const preWarmedState = SpeculativeCompiler.hasValidPreWarm(source, engine)
                    ? SpeculativeCompiler.getPreWarmedState()
                    : null;

                let Module, FS;
                let totalMounted = 0;
                const mountStart = performance.now();
                const ctanFetchedSet = new Set();  // Track CTAN packages fetched (used in retry loop)

                let hadSpeculativeHit = false;
                if (preWarmedState) {
                    // Speculative pre-warm ran - CTAN packages should already be cached in OPFS
                    // We still need to create a fresh WASM and mount bundles, but CTAN fetches
                    // will be instant cache hits instead of network requests
                    log(` SPECULATIVE HIT: Preamble pre-compiled (${preWarmedState.preambleHash})`);
                    log(`   Benefits: CTAN packages cached, bundles in memory`);
                    hadSpeculativeHit = true;

                    // Invalidate pre-warm state (FS can't be reused across WASM instances)
                    SpeculativeCompiler.invalidate();

                    // Fall through to standard compile - but it will be faster because:
                    // 1. Bundles are already in bundleCache (no network fetch)
                    // 2. CTAN packages are in OPFS cache (no network fetch)
                    // 3. WASM module is pre-compiled (cachedWasmModule)
                }

                {
                    // Standard path: init fresh WASM and mount bundles
                    if (!hadSpeculativeHit) {
                        log(`Standard compile (no pre-warm hit)`);
                    }

                    // Init WASM - must create fresh module each time to avoid OOM
                    // (TeX engine doesn't release memory between compiles)
                    Module = await initBusyTeX(true);
                    FS = Module.FS;
                    mountedBundles.clear();  // Fresh FS = nothing mounted yet
                    ctanMountedFiles.clear();  // Clear CTAN file tracking for fresh FS
                    dirNodeCache.clear();    // Fresh FS = clear directory cache

                    // Load all bundles in parallel (into bundleCache)
                    await Promise.all(bundlesToLoad.map(async (bundleName) => {
                        await loadBundle(bundleName);  // Loads into bundleCache
                    }));

                    const enableLazyFS = document.getElementById('enableLazyFS').checked;

                    // Mount files - either lazy (stubs) or eager (full content)
                    if (enableLazyFS) {
                        // LAZY: Create file stubs, content loaded on-demand when accessed
                        for (const bundleName of bundlesToLoad) {
                            const mounted = mountBundleLazy(FS, bundleName);
                            totalMounted += mounted;
                        }
                        log(`Mounted ${totalMounted} lazy file stubs from ${bundlesToLoad.length} bundles`);
                    } else {
                        // EAGER: Copy all file contents upfront (original behavior)
                        for (const bundleName of bundlesToLoad) {
                            if (mountedBundles.has(bundleName)) continue;

                            const bundleData = bundleCache.get(bundleName);
                            const dataView = new Uint8Array(bundleData);

                            for (const [path, info] of Object.entries(fileManifest)) {
                                if (info.bundle === bundleName) {
                                    const dirPath = path.substring(0, path.lastIndexOf('/'));
                                    ensureDirectory(FS, dirPath);
                                    try {
                                        FS.writeFile(path, dataView.slice(info.start, info.end));
                                        totalMounted++;
                                    } catch (e) {}
                                }
                            }
                            mountedBundles.add(bundleName);
                        }
                        log(`Mounted ${totalMounted} files from ${bundlesToLoad.length} bundles`);
                    }

                    // Try to fetch missing packages from CTAN if enabled (with dependencies)
                    const enableCtan = document.getElementById('enableCtan').checked;
                    if (enableCtan && missingPackages.length > 0) {
                        log('Fetching missing packages from CTAN (with dependencies)...');
                        for (const pkg of missingPackages) {
                            await downloadAndMountCTANPackage(pkg, FS, ctanFetchedSet);
                        }
                    }
                }

                const mountTime = performance.now() - mountStart;
                log(`Mount time: ${mountTime.toFixed(0)}ms`);
                filesFetched = totalMounted;
                updateStats();

                log(`Total downloaded: ${(bytesDownloaded / 1024 / 1024).toFixed(2)} MB`);

                // Helper to extract missing file from TeX log
                function extractMissingFile(logContent) {
                    // Match patterns like "! LaTeX Error: File `keyval.sty' not found."
                    // or "! I can't find file `foo.tex'."
                    // or "! Font ... not loadable: Metric (TFM) file not found"
                    // or "!pdfTeX error: ... (file fontname): Font fontname at 600 not found"
                    const patterns = [
                        /! LaTeX Error: File `([^']+)' not found/,
                        /! I can't find file `([^']+)'/,
                        /LaTeX Error: File `([^']+)' not found/,
                        // Font TFM errors - extract the font name from TS1/cmr/m/n/10=tcrm1000
                        /! Font [^=]+=([a-z0-9]+) at .* not loadable: Metric \(TFM\) file/,
                        // pdfTeX Type1 font missing - "!pdfTeX error: ... (file tcrm1000): Font tcrm1000 at 600 not found"
                        /!pdfTeX error:.*\(file ([a-z0-9]+)\): Font .* not found/,
                        // Alternative format - "! Font tcrm1000 at 600 not found."
                        /! Font ([a-z]+\d+) at \d+ not found/
                    ];
                    for (const pattern of patterns) {
                        const match = logContent.match(pattern);
                        if (match) return match[1];
                    }
                    return null;
                }

                // Map font names to packages that provide them
                // EC/TC fonts (ecrm, tcrm, etc.) are provided by cm-super
                function getFontPackage(fontName) {
                    // EC fonts (T1 encoding): ecrm, ecbx, ecti, etc.
                    // TC fonts (TS1 encoding): tcrm, tcbx, tcti, etc.
                    if (/^(ec|tc)[a-z]{2}\d+$/.test(fontName)) {
                        return 'cm-super';
                    }
                    return null;
                }

                // Helper to get package name from file (e.g., keyval.sty -> keyval)
                function getPackageFromFile(filename) {
                    // Check if it's a font name first
                    const fontPkg = getFontPackage(filename);
                    if (fontPkg) return fontPkg;

                    return filename.replace(/\.(sty|cls|tex|def|clo|cfg|fd)$/, '');
                }

                // Always regenerate ls-R (fresh WASM = fresh FS)
                const lsrStart = performance.now();
                const lsRContent = generateLsR(FS, '/texlive/texmf-dist');
                FS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);
                log(`ls-R generated: ${(performance.now() - lsrStart).toFixed(0)}ms`);

                // Write source
                FS.writeFile('/document.tex', source);

                // BREAKTHROUGH: Restore cached aux files for faster compilation
                // If we have aux files from a previous compile with the same preamble,
                // TeX can skip regenerating cross-references, TOC, etc.
                // IMPORTANT: Skip aux restoration if we're using a format file - format-generated
                // aux files may be incompatible with cached aux files from non-format compiles
                // (e.g. \SuspendTagging commands that only exist in full LaTeX preambles)
                const preamble = extractPreambleContent(source);
                const willUseFormat = engine === 'pdflatex' && FormatGenerator.has(preamble, engine);
                const auxPreambleHash = getPreambleHashForAux(source);

                if (!willUseFormat) {
                    const cachedAux = await getAuxCache(auxPreambleHash);
                    if (cachedAux) {
                        const restored = restoreAuxFiles(FS, cachedAux);
                        if (restored > 0) {
                            log(` Restored ${restored} cached aux files (preamble hash: ${auxPreambleHash})`);
                        }
                    }
                }

                // NOTE: Custom format file caching is DISABLED
                // BusyTeX cannot generate format files after WASM has been used for compilation
                // The pdfTeX assertion "glyph_unicode_tree == NULL" fails in tounicode.c

                // Compile with auto-retry for missing files (fetch from CTAN)
                const compileStart = performance.now();
                let pdfData = null;
                const maxRetries = 10;  // Prevent infinite loops
                let retryCount = 0;
                let compileSuccess = false;

                // We need to track files fetched across retries, but reinit WASM each time
                // because TeX engine state is corrupted after a failed run
                let currentModule = Module;
                let currentFS = FS;

                while (!compileSuccess && retryCount < maxRetries) {
                    // For retries, we need a completely fresh WASM module
                    // because TeX engine state is corrupted after failure
                    if (retryCount > 0) {
                        log('Reinitializing WASM for retry...');
                        currentModule = await initBusyTeX(true);
                        currentFS = currentModule.FS;
                        mountedBundles.clear();
                        dirNodeCache.clear();

                        // Re-mount all bundles
                        let totalRemounted = 0;
                        if (enableLazyFS) {
                            for (const bundleName of bundlesToLoad) {
                                totalRemounted += mountBundleLazy(currentFS, bundleName);
                            }
                        } else {
                            for (const bundleName of bundlesToLoad) {
                                totalRemounted += await mountBundle(currentFS, bundleName);
                            }
                        }
                        log(`Re-mounted ${totalRemounted} lazy file stubs from ${bundlesToLoad.length} bundles`);

                        // Re-mount CTAN files from cache (skip files that exist in bundles)
                        // bundleFilenames (global, built in loadManifest) is used to detect duplicates
                        // even when CTAN puts files at different paths than bundles
                        let remounted = 0;
                        let remountFailed = 0;
                        let remountSkipped = 0;
                        for (const filePath of ctanMountedFiles) {
                            // CRITICAL: Don't overwrite files from bundles!
                            // Bundle files were just re-mounted, CTAN versions may be incompatible
                            // Check fileManifest (authoritative) since lazy stubs may not be detected by analyzePath
                            if (fileManifest[filePath]) {
                                remountSkipped++;
                                continue;  // Skip - bundle version takes precedence
                            }

                            // Also check if this is a .sty/.cls file that exists in bundles at a different path
                            // CTAN may use different directory names (e.g., latex-tools vs tools)
                            const filename = filePath.substring(filePath.lastIndexOf('/') + 1);
                            if (bundleFilenames.has(filename) && filePath.includes('/tex/')) {
                                remountSkipped++;
                                continue;  // Skip - bundle has this file at a different path
                            }

                            const content = await readFromOPFS(filePath);
                            if (content) {
                                const dirPath = filePath.substring(0, filePath.lastIndexOf('/'));
                                ensureDirectory(currentFS, dirPath);
                                try {
                                    currentFS.writeFile(filePath, content);
                                    remounted++;
                                } catch (e) {
                                    remountFailed++;
                                }
                            } else {
                                remountFailed++;
                            }
                        }
                        log(`Re-mounted ${remounted}/${ctanMountedFiles.size} CTAN files (${remountSkipped} skipped, ${remountFailed} failed)`);

                        // Re-append font map files to pdftex.map (lost during WASM reinit)
                        if (ctanFontMapFiles.size > 0 && engine === 'pdflatex') {
                            log(`Re-appending ${ctanFontMapFiles.size} font map files...`);
                            await appendCachedMapsToUpdmap(currentFS, Array.from(ctanFontMapFiles));
                        }

                        // Re-copy .enc files to standard location (lost during WASM reinit)
                        // Build a files object from ctanMountedFiles for copyEncFilesToStandardLocation
                        const ctanFilesObj = {};
                        for (const f of ctanMountedFiles) ctanFilesObj[f] = true;
                        copyEncFilesToStandardLocation(currentFS, ctanFilesObj);

                        // Regenerate ls-R
                        const lsRContent = generateLsR(currentFS, '/texlive/texmf-dist');
                        currentFS.writeFile('/texlive/texmf-dist/ls-R', lsRContent);

                        // Debug: verify critical font files exist
                        const pfbPath = '/texlive/texmf-dist/fonts/type1/public/cm-super/sfrm1000.pfb';
                        const encPath = '/texlive/texmf-dist/fonts/enc/dvips/cm-super/cm-super-ts1.enc';
                        const encOrigPath = '/texlive/texmf-dist/fonts/type1/public/cm-super/cm-super-ts1.enc';
                        log(`DEBUG: sfrm1000.pfb exists: ${currentFS.analyzePath(pfbPath).exists}`);
                        log(`DEBUG: cm-super-ts1.enc (copied): ${currentFS.analyzePath(encPath).exists}`);
                        log(`DEBUG: cm-super-ts1.enc (orig): ${currentFS.analyzePath(encOrigPath).exists}`);

                        // Check if file is in ls-R
                        const lsRCheck = lsRContent.includes('sfrm1000.pfb');
                        log(`DEBUG: sfrm1000.pfb in ls-R: ${lsRCheck}`);

                        // Check pdftex.map has the tcrm1000 entry
                        try {
                            const mapContent = new TextDecoder().decode(currentFS.readFile('/texlive/texmf-dist/texmf-var/fonts/map/pdftex/updmap/pdftex.map'));
                            const hasEntry = mapContent.includes('tcrm1000');
                            log(`DEBUG: tcrm1000 in pdftex.map: ${hasEntry}`);
                        } catch(e) {
                            log(`DEBUG: Failed to read pdftex.map: ${e.message}`);
                        }

                        // Patch texmf.cnf to add explicit cm-super paths
                        // kpathsea reads this at runtime for path searching
                        try {
                            const texmfCnfPath = '/texlive/texmf-dist/web2c/texmf.cnf';
                            let texmfCnf = new TextDecoder().decode(currentFS.readFile(texmfCnfPath));

                            // Add cm-super to T1FONTS path if not already present
                            if (!texmfCnf.includes('cm-super')) {
                                // Append explicit cm-super paths at the end
                                texmfCnf += '\n% Added by Siglum for cm-super font support\n';
                                texmfCnf += 'T1FONTS = /texlive/texmf-dist/fonts/type1/public/cm-super:$T1FONTS\n';
                                texmfCnf += 'ENCFONTS = /texlive/texmf-dist/fonts/enc/dvips/cm-super:/texlive/texmf-dist/fonts/type1/public/cm-super:$ENCFONTS\n';
                                currentFS.writeFile(texmfCnfPath, texmfCnf);
                                log('DEBUG: Patched texmf.cnf with cm-super paths');
                            }
                        } catch(e) {
                            log(`DEBUG: Failed to patch texmf.cnf: ${e.message}`);
                        }
                    }

                    // Write source (with pdflatex-specific workarounds)
                    let sourceToWrite = source;
                    if (engine === 'pdflatex') {
                        // Disable microtype font expansion - we don't have cm-super Type1 fonts
                        sourceToWrite = injectMicrotypeWorkaround(sourceToWrite);

                        // Always inject base CM font maps for pdflatex
                        // The BusyTeX format doesn't include proper map data, so we need \pdfmapfile
                        const baseMaps = [
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cm.map',  // Computer Modern base fonts
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cmextra.map',  // CM extra fonts
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/symbols.map',  // AMS symbols (msam/msbm)
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/euler.map',  // Euler math fonts
                            '/texlive/texmf-dist/fonts/map/dvips/amsfonts/latxfont.map',  // LaTeX text fonts
                        ];
                        // Add any CTAN-fetched font maps
                        const allMaps = [...baseMaps, ...Array.from(ctanFontMapFiles)];
                        // Filter to maps that exist in the filesystem
                        const existingMaps = allMaps.filter(m => currentFS.analyzePath(m).exists);
                        const missingMaps = allMaps.filter(m => !currentFS.analyzePath(m).exists);
                        if (missingMaps.length > 0) {
                            log(`Font maps not found in FS: ${missingMaps.join(', ')}`);
                        }
                        if (existingMaps.length > 0) {
                            sourceToWrite = injectPdfMapFileCommands(sourceToWrite, existingMaps);
                        } else {
                            log('Warning: No font map files found - fonts may not render correctly');
                        }
                    }
                    currentFS.writeFile('/document.tex', sourceToWrite);

                    let exitCode;
                    let logContent = '';

                    if (engine === 'pdflatex') {
                        // Check if we have a custom format for this preamble
                        const preamble = extractPreambleContent(source);
                        let fmtPath = '/texlive/texmf-dist/texmf-var/web2c/pdftex/pdflatex.fmt';
                        let docSource = sourceToWrite;

                        if (FormatGenerator.has(preamble, engine)) {
                            const customFmt = FormatGenerator.formats.get(
                                `${FormatGenerator.hashPreamble(preamble)}_${engine}`
                            );
                            if (customFmt) {
                                // Mount the custom format
                                currentFS.writeFile('/custom.fmt', customFmt);
                                fmtPath = '/custom.fmt';

                                const cacheKey = `${FormatGenerator.hashPreamble(preamble)}_${engine}`;

                                // On FIRST use of a format, delete auxiliary files - they may contain
                                // commands from a previous non-format compilation (e.g. \SuspendTagging)
                                // After first successful compile with format, aux files are compatible
                                if (!FormatGenerator.usedFormats.has(cacheKey)) {
                                    log('First use of format - clearing stale aux files');
                                    const auxExtensions = ['.aux', '.toc', '.out', '.lof', '.lot', '.nav', '.snm'];
                                    for (const ext of auxExtensions) {
                                        const auxPath = '/document' + ext;
                                        if (currentFS.analyzePath(auxPath).exists) {
                                            currentFS.unlink(auxPath);
                                        }
                                    }
                                    FormatGenerator.usedFormats.add(cacheKey);
                                }

                                // Strip the preamble - format already has it baked in
                                // The format contains: documentclass + usepackage commands (compiled)
                                // The document needs: \begin{document}...\end{document}
                                const bodyMatch = source.match(/\\begin\{document\}([\s\S]*)$/);
                                if (bodyMatch) {
                                    // Build font map commands - these need to be AFTER \begin{document}
                                    // because that's when pdfTeX reads them
                                    const fontMaps = [
                                        '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cm.map',
                                        '/texlive/texmf-dist/fonts/map/dvips/amsfonts/cmextra.map',
                                        '/texlive/texmf-dist/fonts/map/dvips/amsfonts/symbols.map',
                                        '/texlive/texmf-dist/fonts/map/dvips/amsfonts/euler.map',
                                        '/texlive/texmf-dist/fonts/map/dvips/amsfonts/latxfont.map',
                                        ...Array.from(ctanFontMapFiles)
                                    ].filter(m => currentFS.analyzePath(m).exists);

                                    // Font maps go right after \begin{document}
                                    let mapCmds = '';
                                    if (fontMaps.length > 0) {
                                        mapCmds = fontMaps.map(m => `\\pdfmapfile{+${m}}`).join('\n') + '\n';
                                    }

                                    docSource = '\\begin{document}\n' + mapCmds + bodyMatch[1];
                                }
                                currentFS.writeFile('/document.tex', docSource);
                                log(`Using custom format (${(customFmt.byteLength / 1024 / 1024).toFixed(1)}MB)`);
                            }
                        }

                        // pdfLaTeX: produces PDF directly
                        const pdflatexResult = currentModule.callMainWithRedirects([
                            'pdflatex',
                            '--no-shell-escape',
                            '--interaction=nonstopmode',
                            '--halt-on-error',
                            '--fmt', fmtPath,
                            '/document.tex'
                        ]);
                        exitCode = pdflatexResult.exit_code;
                        const compileTime = performance.now() - compileStart;
                        log(`pdfLaTeX: ${compileTime.toFixed(0)}ms (exit: ${exitCode})`);

                        if (exitCode === 0) {
                            try {
                                pdfData = currentFS.readFile('/document.pdf');
                                compileSuccess = true;
                            } catch (e) {}
                        }
                    } else {
                        // XeLaTeX: produces XDV, then convert to PDF
                        const xetexResult = currentModule.callMainWithRedirects([
                            'xelatex',
                            '--no-shell-escape',
                            '--interaction=nonstopmode',
                            '--halt-on-error',
                            '--no-pdf',
                            '--fmt', '/texlive/texmf-dist/texmf-var/web2c/xetex/xelatex.fmt',
                            '/document.tex'
                        ]);
                        exitCode = xetexResult.exit_code;
                        const xetexTime = performance.now() - compileStart;
                        log(`XeTeX: ${xetexTime.toFixed(0)}ms (exit: ${exitCode})`);

                        // Convert to PDF
                        if (exitCode === 0 && currentFS.analyzePath('/document.xdv').exists) {
                            log('Running xdvipdfmx...');
                            const dvipdfmxResult = currentModule.callMainWithRedirects([
                                'xdvipdfmx',
                                '-v',  // verbose
                                '-o', '/document.pdf',
                                '/document.xdv'
                            ], true);  // enable print output
                            log(`xdvipdfmx exit: ${dvipdfmxResult.exit_code}`);
                            if (dvipdfmxResult.exit_code !== 0) {
                                log(`xdvipdfmx stdout: ${dvipdfmxResult.stdout}`);
                                log(`xdvipdfmx stderr: ${dvipdfmxResult.stderr}`);
                            }
                            try {
                                pdfData = currentFS.readFile('/document.pdf');
                                compileSuccess = true;
                            } catch (e) {}
                        }
                    }

                    // If compile failed, check for missing file and try to fetch from CTAN
                    if (!compileSuccess && enableCtan) {
                        try {
                            logContent = new TextDecoder().decode(currentFS.readFile('/document.log'));
                        } catch (e) {
                            logContent = '';
                        }

                        const missingFile = extractMissingFile(logContent);
                        if (missingFile) {
                            const pkgName = getPackageFromFile(missingFile);
                            if (!ctanFetchedSet.has(pkgName)) {
                                log(`Missing file detected: ${missingFile}`);
                                log(`Fetching package '${pkgName}' from CTAN...`);
                                // Note: we pass currentFS here for initial mount, but files
                                // will be re-mounted from OPFS cache on retry with fresh WASM
                                const fetched = await downloadAndMountCTANPackage(pkgName, currentFS, ctanFetchedSet);
                                if (fetched) {
                                    retryCount++;
                                    log(`Retrying compilation (attempt ${retryCount + 1})...`);
                                    continue;
                                }
                            }
                        }
                        // No missing file detected or couldn't fetch - stop retrying
                        break;
                    }
                }

                if (retryCount >= maxRetries) {
                    log(`Stopped after ${maxRetries} retries - possible circular dependency`);
                }

                const compileTime = ((performance.now() - totalStartTime) / 1000).toFixed(2);
                const totalTime = ((performance.now() - totalStartTime) / 1000).toFixed(2);
                document.getElementById('time').textContent = `Total: ${totalTime}s (compile: ${compileTime}s)`;

                // Update stats after compile (to show lazy loads)
                updateStats();

                // Record result for engine learning
                const compileTimeMs = performance.now() - totalStartTime;
                const success = pdfData && pdfData.byteLength > 0;
                EngineSelector.recordResult(source, {
                    engine,
                    success,
                    timeMs: compileTimeMs,
                    retries: retryCount,
                    triggeredCmSuper
                });
                if (triggeredCmSuper && engine === 'pdflatex') {
                    log('Note: cm-super fonts triggered - will prefer xelatex next time');
                }

                if (success) {
                    // BREAKTHROUGH: Save aux files for faster recompilation
                    // These files help TeX skip regenerating cross-refs, TOC, etc.
                    // NOTE: Skip saving aux files when using format mode - they contain
                    // incompatible content (no \SuspendTagging etc.)
                    if (!willUseFormat) {
                        const newAuxFiles = collectAuxFiles(currentFS);
                        const auxFileCount = Object.keys(newAuxFiles).length;
                        if (auxFileCount > 0) {
                            await saveAuxCache(auxPreambleHash, newAuxFiles);
                            log(` Cached ${auxFileCount} aux files for faster recompile`);
                        }
                    }

                    // BREAKTHROUGH: Cache PDF for instant results on same document
                    await saveCachedPdf(docHash, engine, pdfData);
                    log(` Cached PDF for instant recompile`);

                    // NOTE: Custom format file generation is DISABLED
                    // BusyTeX cannot generate format files after the WASM module has been used
                    // for compilation - it triggers an assertion error in pdfTeX's tounicode.c
                    // The assertion: "glyph_unicode_tree == NULL"
                    //
                    // Potential solutions:
                    // 1. Generate format in a Web Worker with fresh WASM instance
                    // 2. Pre-generate formats for common preambles (memoir, article+packages, etc.)
                    // 3. Use WASM memory snapshots instead of TeX format files
                    //
                    // For now, we rely on:
                    // - Document hash caching (instant for unchanged docs)
                    // - Aux file caching (helps with cross-references)
                    // - CTAN file caching (no re-downloads)

                    // Use incremental PDF viewer - only re-renders changed pages
                    if (window.IncrementalPDFViewer) {
                        await window.IncrementalPDFViewer.render(pdfData);
                    }
                    log(`\nSuccess! PDF: ${(pdfData.byteLength / 1024).toFixed(1)} KB`);
                    if (enableLazyFS) {
                        log(`Lazy loaded ${lazyLoadCount} of ${totalMounted} files (${((lazyLoadCount/totalMounted)*100).toFixed(1)}%) in ${lazyLoadTotalTime.toFixed(1)}ms`);
                    }
                    log(`Downloaded: ${(bytesDownloaded / 1024 / 1024).toFixed(2)} MB in ${requestCount} requests`);
                } else {
                    log('\nNo PDF output.');
                    try {
                        const logContent = new TextDecoder().decode(currentFS.readFile('/document.log'));
                        const errorMatch = logContent.match(/^!.*$/m);
                        if (errorMatch) log(`Error: ${errorMatch[0]}`);
                    } catch (e) {}
                }
            } catch (e) {
                log('Error: ' + e.message);
                console.error(e);
            } finally {
                btn.disabled = false;
                btn.textContent = 'Compile (Lazy Loading)';
            }
        }

        // Pre-warm: load WASM, manifest, and bundles in background on page load
        // This runs before user clicks compile, so first compile is faster
        async function preWarm() {
            const source = document.getElementById('source').value;
            const engine = getSelectedEngine(source);

            console.log(`Pre-warming for ${engine}...`);

            // Load everything in parallel
            await Promise.all([
                loadManifest(),
                loadBundleDeps(),
                // Pre-compile WASM module
                (async () => {
                    if (!busytexScriptLoaded) {
                        await new Promise((resolve, reject) => {
                            const script = document.createElement('script');
                            script.src = 'busytex.js';
                            script.onload = resolve;
                            script.onerror = reject;
                            document.head.appendChild(script);
                        });
                        busytexScriptLoaded = true;
                    }
                    // Pre-compile the WASM module
                    if (!cachedWasmModule) {
                        const response = await fetch('busytex.wasm');
                        const wasmBytes = await response.arrayBuffer();
                        cachedWasmModule = await WebAssembly.compile(wasmBytes);
                    }
                })()
            ]);

            // Pre-load bundles for detected packages
            const { bundles } = checkPackages(source, engine);
            await Promise.all(bundles.map(b => loadBundle(b)));

            preWarmedEngine = engine;
            console.log(`Pre-warm complete: ${bundles.length} bundles cached`);
        }

        // ============================================================
        // Auto-compile with configurable triggers
        // ============================================================
        const AutoCompile = {
            // === CONFIGURABLE HEURISTICS ===
            debounceMs: 1000,           // Wait this long after last keystroke
            wordBoundaryMs: 500,        // Shorter delay after word completion (space, punctuation)
            saveDelayMs: 0,             // Immediate compile on Ctrl/Cmd+S
            minTimeBetweenCompiles: 500, // Don't compile more often than this

            // Internal state
            timer: null,
            lastCompileTime: 0,
            isCompiling: false,
            lastSource: '',

            isEnabled() {
                return document.getElementById('enableAutoCompile').checked;
            },

            schedule(delayMs) {
                if (!this.isEnabled()) return;
                if (this.isCompiling) return;

                // Don't schedule if source hasn't changed
                const currentSource = document.getElementById('source').value;
                if (currentSource === this.lastSource) return;

                clearTimeout(this.timer);
                this.timer = setTimeout(() => this.triggerCompile(), delayMs);
            },

            async triggerCompile() {
                if (this.isCompiling) return;

                const now = Date.now();
                if (now - this.lastCompileTime < this.minTimeBetweenCompiles) {
                    // Too soon, reschedule
                    this.schedule(this.minTimeBetweenCompiles - (now - this.lastCompileTime));
                    return;
                }

                const currentSource = document.getElementById('source').value;
                if (currentSource === this.lastSource) return;

                this.isCompiling = true;
                this.lastSource = currentSource;
                this.lastCompileTime = now;

                try {
                    await compileWithLazyLoading();
                } finally {
                    this.isCompiling = false;
                }
            },

            cancel() {
                clearTimeout(this.timer);
            }
        };

        // Real-time package checking + auto-compile + speculative pre-compilation
        document.getElementById('source').addEventListener('input', (e) => {
            const source = document.getElementById('source').value;

            if (packageMap) {
                checkPackages(source, getSelectedEngine());
            }

            // BREAKTHROUGH: Trigger speculative pre-compilation when preamble changes
            // This runs in background while user edits, so next compile is faster
            SpeculativeCompiler.onSourceChange(source);

            // Auto-compile with debounce
            AutoCompile.schedule(AutoCompile.debounceMs);
        });

        // Shorter delay after word boundaries (space, newline, punctuation)
        document.getElementById('source').addEventListener('keyup', (e) => {
            // Immediate compile on every keyup (aggressive mode)
            if (document.getElementById('enableKeyupCompile').checked) {
                AutoCompile.schedule(300);  // Wait for typing pause before compiling
                return;
            }

            if (!AutoCompile.isEnabled()) return;

            // Word boundary characters trigger faster compile
            if (e.key === ' ' || e.key === 'Enter' || e.key === '.' || e.key === '}' || e.key === '$') {
                AutoCompile.schedule(AutoCompile.wordBoundaryMs);
            }
        });

        // Immediate compile on Ctrl/Cmd+S
        document.getElementById('source').addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                e.preventDefault();  // Prevent browser save dialog
                if (AutoCompile.isEnabled()) {
                    AutoCompile.schedule(AutoCompile.saveDelayMs);
                } else {
                    compileWithLazyLoading();
                }
            }
        });

        // Re-check packages when engine changes
        document.getElementById('engineSelect').addEventListener('change', () => {
            if (packageMap) {
                const source = document.getElementById('source').value;
                checkPackages(source, getSelectedEngine());
            }
        });

        // Initial load and pre-warm
        loadBundleDeps().then(() => {
            const source = document.getElementById('source').value;
            checkPackages(source, getSelectedEngine());

            // Start pre-warming in background after initial page setup
            setTimeout(() => preWarm(), 100);

            // BREAKTHROUGH: Also start speculative compilation for current document
            // This runs a full preamble compile in background so first user compile is instant
            setTimeout(() => {
                const source = document.getElementById('source').value;
                SpeculativeCompiler.startPreWarm(source, SpeculativeCompiler.hashPreamble(source));
            }, 1000);  // Wait 1s for basic pre-warm to complete
        });
    </script>
</body>
</html>
